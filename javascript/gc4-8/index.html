<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第八章 对象、类与面向对象编程 | Ghosie的博客</title><meta name="keywords" content="javascript,高程4笔记"><meta name="author" content="郭伟杰"><meta name="copyright" content="郭伟杰"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="理解对象 ECMA-262 将对象定义为一组属性的无序集合。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值  属性的类型ECMA-262 使用一些内部特性来描述属性的特征，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如 [[Enumerable]] 属性分两种：数据属性和访问器属性1、数据属性数据属性包">
<meta property="og:type" content="article">
<meta property="og:title" content="第八章 对象、类与面向对象编程">
<meta property="og:url" content="https://keep-silence.com/javascript/gc4-8/index.html">
<meta property="og:site_name" content="Ghosie的博客">
<meta property="og:description" content="理解对象 ECMA-262 将对象定义为一组属性的无序集合。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值  属性的类型ECMA-262 使用一些内部特性来描述属性的特征，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如 [[Enumerable]] 属性分两种：数据属性和访问器属性1、数据属性数据属性包">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://keep-silence.com/images/class.webp">
<meta property="article:published_time" content="2021-12-15T07:10:58.000Z">
<meta property="article:modified_time" content="2023-03-20T22:55:00.000Z">
<meta property="article:author" content="郭伟杰">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="高程4笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://keep-silence.com/images/class.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://keep-silence.com/javascript/gc4-8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第八章 对象、类与面向对象编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-21 06:55:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myHtml/on2job.html"><i class="fa-fw fas fa-gamepad"></i><span> 摸鱼</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://win11.keep-silence.com"><i class="fa-fw fab fa-windows"></i><span> win11</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.php.cn/upload/article/000/000/015/5ce218f69bcc9461.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ghosie的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myHtml/on2job.html"><i class="fa-fw fas fa-gamepad"></i><span> 摸鱼</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://win11.keep-silence.com"><i class="fa-fw fab fa-windows"></i><span> win11</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第八章 对象、类与面向对象编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-15T07:10:58.000Z" title="发表于 2021-12-15 15:10:58">2021-12-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-20T22:55:00.000Z" title="更新于 2023-03-21 06:55:00">2023-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/javascript/">javascript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第八章 对象、类与面向对象编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><blockquote>
<p>ECMA-262 将对象定义为一组属性的无序集合。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值</p>
</blockquote>
<h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>ECMA-262 使用一些内部特性来描述属性的特征，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如 <code>[[Enumerable]]</code></p>
<p>属性分两种：数据属性和访问器属性<br><strong>1、数据属性</strong><br>数据属性包含一个保存数据值的位置。值从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为：</p>
<ul>
<li>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认值为false。默认情况下，所有直接定义在对象上的属性的这个特性都是 true</li>
<li>[[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认值为false。默认情况下，所有直接定义在对象上的属性的这个特性都是 true</li>
<li>[[Writable]]：表示属性的值是否可以修改。默认值为false。默认情况下，所有直接定义在对象上的属性的这个特性都是 true</li>
<li>[[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。默认值为 undefined</li>
</ul>
<p>要修改属性的默认特性，就必须使用 <code>Object.defineProperty()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">&#x27;name&#x27;</span>,&#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">&#x27;Neo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;Neo&#x27;</span></span><br><span class="line">person.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;Neo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>writable 为 false 即 值不能在修改了，在非严格模式下尝试给这个属性重新赋值会被忽略；在严格模式下，尝试修改只读属性的值会抛出错误</p>
<p>一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用 Object.defineProperty() 并修改任何非 writable 属性会导致错误</p>
<p><strong>2、访问器属性</strong><br>访问器属性包含一个 getter 函数和一个 setter 函数，不过这两个函数不是必须的。访问器属性有4个特性描述它们的行为：</p>
<ul>
<li>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，是否可以把它改为数据属性</li>
<li>[[Enumerable]]：表示属性是否可以通过 for-in 循环返回</li>
<li>[[Get]]：获取函数，在读取属性时调用。默认值为 undefined</li>
<li>[[Set]]：设置函数，在写入属性时调用。默认值为 undefined</li>
</ul>
<p>访问器属性必须使用 <code>Object.defineProperty()</code> 定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    year_: <span class="number">2017</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&#x27;year&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.year_</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.year_ = newValue</span><br><span class="line">            <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year = <span class="number">2018</span></span><br><span class="line"><span class="built_in">console</span>.log(book.edition) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>以上例子中，对象 book 有两个默认属性：year_和 edition。year_ 中的下划线常用来表示<code>该属性并不希望在对象方法的外部被访问</code>。另一个属性 year 被定义为一个访问器属性，设置一个属性值会导致一些其他的变化，这是放问题属性的典型使用场景</p>
<p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略；类似的，只有一个设置函数的属性是不能读取的，非严格模式下会返回 undefined ，严格模式下会抛出错误</p>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>Object.defineProperties()<br>接收两个参数：要添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改 的属性一一对应</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    year_:&#123;</span><br><span class="line">        value: <span class="number">2017</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue &gt; <span class="number">2017</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.year_ = newValue</span><br><span class="line">                <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上代码在 book 对象上定义了两个数据属性 year_ 和 edition ，还有一个访问器属性 year。最终的对象跟上一节实例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的 configurable、enumerable 和 writable 特性值都是 false</p>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>Object.getOwnPropertyDescriptor()<br>获取指定属性的属性描述符。接收两个参数：属性所在的对象和属性名。返回值是一个对象，对于访问器属性包含 configurable、enumerable、get 和 set，对于数据属性包含 configurable、enumerable、writable 和 value</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    year_:&#123;</span><br><span class="line">        value: <span class="number">2017</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue &gt; <span class="number">2017</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.year_ = newValue</span><br><span class="line">                <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">&#x27;year_&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// 2017</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get) <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">&#x27;year&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get) <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对于数据属性 year_，value 等于原来的值，configurable 是 false，get 是 undefined<br>对于访问器属性 year，value 是 undefined，enumerable 是 false, get 是一个指向获取函数的指针</p>
<p>ECMAScript 2017 新增了 <code>Object.getOwnPropertyDescriptors()</code> 静态方法，这个方法会在每个自由属性上调用 Object.getOwnPropertyDescriptor() 并在一个新对象中返回它们。类似与 Object.defineProperty() 与 Object.definePropertise()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    year_:&#123;</span><br><span class="line">        value: <span class="number">2017</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue &gt; <span class="number">2017</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.year_ = newValue</span><br><span class="line">                <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(book))</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//      edition: &#123; </span></span><br><span class="line"><span class="comment">//          configurable: false, </span></span><br><span class="line"><span class="comment">//          enumerable: false, </span></span><br><span class="line"><span class="comment">//          value: 1, </span></span><br><span class="line"><span class="comment">//          writable: false </span></span><br><span class="line"><span class="comment">//      &#125;, </span></span><br><span class="line"><span class="comment">//      year: &#123; </span></span><br><span class="line"><span class="comment">//          configurable: false, </span></span><br><span class="line"><span class="comment">//          enumerable: false, </span></span><br><span class="line"><span class="comment">//          get: f(), </span></span><br><span class="line"><span class="comment">//          set: f(newValue), </span></span><br><span class="line"><span class="comment">//      &#125;, </span></span><br><span class="line"><span class="comment">//      year_: &#123; </span></span><br><span class="line"><span class="comment">//          configurable: false, </span></span><br><span class="line"><span class="comment">//          enumerable: false, </span></span><br><span class="line"><span class="comment">//          value: 2017, </span></span><br><span class="line"><span class="comment">//          writable: false </span></span><br><span class="line"><span class="comment">//      &#125; </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="对象合并"><a href="#对象合并" class="headerlink" title="对象合并"></a>对象合并</h3><p>Object.assign()<br>接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中<code>可枚举</code>（Object.propertyIsEnmuerable()返回true）和<code>自有属性</code>（Object.hasOwnProperty()返回true）复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的 [[Get]] 取得属性的值，然后使用目标对象上的 [[Set]] 设置属性的值</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target,...sources)</span><br><span class="line"><span class="comment">// target -&gt; 目标对象</span></span><br><span class="line"><span class="comment">// sources -&gt; 源对象</span></span><br><span class="line"><span class="comment">// 返回值： 目标对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> src = &#123; <span class="attr">id</span>: <span class="string">&#x27;src&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Object</span>.assign(dest,src)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dest)  <span class="comment">// &#123;id:&#x27;src&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// &#123;id:&#x27;src&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest === result) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(dest !== src) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数与设置函数</span></span><br><span class="line">dest = &#123;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">src = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;ooo&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest,src) <span class="comment">// 调用 src 的获取方法，调用 dest 的设置方法并传入参数&#x27;foo&#x27;，因为这里的设置函数不执行赋值操作，所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="built_in">console</span>.log(dest) <span class="comment">// &#123;set a(val)&#123;...&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>Object.assign() 对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋值给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数</p>
<p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。抛出错误之前，目标对象上已经完成的修改会继续存在</p>
<h3 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h3><p>Object.is()<br>判断两个值是否为同一个值，如果满足以下条件则两个值相等</p>
<ul>
<li>都是 undefined</li>
<li>都是 null</li>
<li>都是 true 或 false</li>
<li>都是相同长度的字符串且相同字符按相同顺序排列</li>
<li>都是相同对象（意味着每个对象有同一个引用）</li>
<li>都是数字且<ul>
<li>都是 +0</li>
<li>都是 -0</li>
<li>都是 NaN</li>
<li>或都是非零且非 NaN 且为同一个值</li>
</ul>
</li>
</ul>
<h3 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h3><p><strong>1、可计算属性</strong><br>可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span></span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&#x27;job&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [nameKey]: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    [ageKey]: <span class="number">27</span>,</span><br><span class="line">    [jobKey]: <span class="string">&#x27;software engineer&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123;name: &#x27;Matt&#x27;, age: 27, job: &#x27;software engineer&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span></span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&#x27;job&#x27;</span></span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueKey</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_<span class="subst">$&#123;uniqueToken++&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [getUniqueKey(nameKey)]: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    [getUniqueKey(ageKey)]: <span class="number">27</span>,</span><br><span class="line">    [getUniqueKey(jobKey)]: <span class="string">&#x27;software engineer&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123; name_0: &#x27;Matt&#x27;, age_1: 27, job_2: &#x27;software engineer&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可计算属性表达式中抛出任何错误都会中断对象创建</p>
</blockquote>
<p><strong>2、简写方法名</strong><br>如果对象的某个值为函数，则可以省略该值的键<br>简写方法名对获取函数和设置函数也是适用的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name_: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name_</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name_ = name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;htis.name_&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">person.sayName() <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure>

<p>简写方法名与可计算属性键相互兼容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodKey = <span class="string">&#x27;sayName&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [methodKey](name)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayName(<span class="string">&#x27;Matt&#x27;</span>) <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p><strong>1、直接使用原对象的属性名</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<p><strong>2、声明自己的变量</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge &#125; = person</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personName) <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(personAge) <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<p><strong>3、解构赋值不一定与对象的属性匹配</strong><br>赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, job &#125; = person</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(job) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>也可以在结构赋值的同时定义默认值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, job=<span class="string">&#x27;developer&#x27;</span> &#125; = person</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(job) <span class="comment">// &#x27;developer&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>4、解构原理</strong><br>解构在内部使用函数 <code>ToObject()</code>（不能在运行时环境中直接访问）把源数据解构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据 ToObject() 的定义），null 和 undefined 不能被解构，否则会抛出错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length &#125; = <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(length) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">constructor</span>: c &#125; = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(c === <span class="built_in">Number</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">null</span> <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">undefined</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<p><strong>5、解构声明</strong><br>解构并不要求变量必须在解构表达式中声明。如果给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(&#123;<span class="attr">name</span>: personName, <span class="attr">age</span>: personAge&#125; = person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personName,personAge) <span class="comment">// Matt,27</span></span><br></pre></td></tr></table></figure>

<p><strong>6、嵌套解构</strong><br>1、解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来赋值对象属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    age: <span class="number">27</span>,</span><br><span class="line">    job: &#123;</span><br><span class="line">        title: <span class="string">&#x27;cleaner&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;</span><br><span class="line"></span><br><span class="line">(&#123;</span><br><span class="line">    name: personCopy.name,</span><br><span class="line">    age: personCopy.age,</span><br><span class="line">    job: personCopy.job</span><br><span class="line">&#125; = person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personCopy) <span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;cleaner&#x27; &#125; &#125; 此处 job 赋值的是引用地址</span></span><br></pre></td></tr></table></figure>

<p>2、解构赋值可以使用嵌套解构，以匹配嵌套的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    age: <span class="number">27</span>,</span><br><span class="line">    job: &#123;</span><br><span class="line">        title: <span class="string">&#x27;cleaner&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 title 变量并将 person.job.title 的值赋值给它</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">job</span>: &#123; title &#125; &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(title) <span class="comment">// cleaner</span></span><br></pre></td></tr></table></figure>

<p>3、在外层属性没有定义的情况下，不能使用嵌套解构。无论源对象还是目标对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    job: &#123;</span><br><span class="line">        title: <span class="string">&#x27;cleaner&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 在源对象上是 undefined</span></span><br><span class="line">(&#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        bar: personCopy.bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125; = person)</span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property &#x27;bar&#x27; of &#x27;undefined&#x27; or &#x27;null&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// job 在目标对象上是 undefined</span></span><br><span class="line">(&#123;</span><br><span class="line">    job: &#123;</span><br><span class="line">        title: personCopy.job.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125; = person)</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;title&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>7、部分解构</strong><br>涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分</p>
<p><strong>8、参数上下文匹配</strong><br>在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明在函数体内使用局部变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson</span>(<span class="params">foo,&#123;name, age&#125;, bar</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(name,age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson2</span>(<span class="params">foo,&#123;name: personName, age: personAge&#125;, bar</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(personName, personAge)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPerson(<span class="string">&#x27;list&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;list&#x27;, &#123;name: &#x27;Matt&#x27;, age: 27&#125;, &#x27;2nd&#x27;]</span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27</span></span><br><span class="line"></span><br><span class="line">printPerson2(<span class="string">&#x27;list&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;list&#x27;, &#123;name: &#x27;Matt&#x27;, age: 27&#125;, &#x27;2nd&#x27;]</span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27</span></span><br></pre></td></tr></table></figure>

<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.job = job</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">&#x27;Jeff&#x27;</span>, <span class="number">29</span>, <span class="string">&#x27;cleaner&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">&#x27;Greg&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;Doctor&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里，函数 createPerson() 接收3个参数，根据这几个参数构建了一个包含 Person 信息的对象。可以用不同的参数多次调用这个函数，每次都会返回包含3个属性和一个方法的对象。这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><blockquote>
<p>构造函数是用于创建<code>特定类型对象</code>的函数，也叫类</p>
</blockquote>
<blockquote>
<p>构造函数模式的目的是为了创建一个自定义类，并且创建这个类的实例</p>
</blockquote>
<p>创建实例应使用 new 操作符，以这种方式调用构造函数会执行如下操作：<br>1、在内存中创建一个新对象<br>2、这个新对象内部的 [[Prototype]] 特性被赋值为构造函数的 prototype 属性<br>3、构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）<br>4、执行构造函数内部的代码（给新对象添加属性）<br>5、如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</p>
<blockquote>
<p>构造函数模式中，浏览器会默认返回实例（对象数据类型的值），如果手动写了return：</p>
<ul>
<li>return 一个基本数据类型的值，当前实例不变。如 return 100 , 会正常返回实例</li>
<li>return 一个引用数据类型的值，则实例会被该返回值给替换</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Fn(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)  <span class="comment">// &#x27;Jack&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Fn(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)  <span class="comment">// &#x27;Jack&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Fn(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">&#x27;Jeff&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Fn(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)  <span class="comment">// &#x27;Jeff&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Fn) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Fn = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age，</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数的问题：<br>构造函数定义的方法在每个实例上都会创建一遍,对于上面的例子，每生成一个新的实例，都会有一个 sayName() 的方法，但这两个方法不是同一个 Function 实例，这就导致了相同逻辑的函数重复定义的问题。该问题可以通过原型模式来解决</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享</p>
<p><strong>1、理解原型</strong><br>只要创建一个函数，就会为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数</p>
<p>在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object。每次调用构造函数创建一个新实例，这个实例的内部 [[Prototype]] 指针就会被赋值为构造函数的原型对象。脚本中没有访问这个 [[Prototype]] 特性的标准方式，但 Firefox、Safari 和 Chrome 会在每个对象上暴露 <strong>proto</strong> 属性，通过这个属性可以访问对象的原型。关键在于理解这一点：<strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有</strong></p>
<p>可以使用 <code>isPrototypeOf()</code> 方法确定两个对象之间的关系。本质上，isPrototypeOf() 会在传入参数的 [[Prototype]] 指向调用它的对象时返回 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Fn.prototype.isPrototypeOf(p1)) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>ECMAScript 的 Object 类型有一个方法叫 Object.getPrototypeOf()，返回参数的内部特性 [[Prototype]] 的值。这在通过原型实现继承时显得尤为重要！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Fn(name,age) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype &#x3D; &#123;</span><br><span class="line">    name: &#39;haha&#39;</span><br><span class="line">&#125;</span><br><span class="line">let p1 &#x3D; new Fn(&#39;jack&#39;,27)</span><br><span class="line">console.log(Object.getPrototypeOf(p1) &#x3D;&#x3D; Fn.prototye) &#x2F;&#x2F; true</span><br><span class="line">console.log(Object.getPrototypeOf(p1).name); &#x2F;&#x2F; haha</span><br></pre></td></tr></table></figure>

<p>Object 类型还有一个 <code>setPrototypeOf()</code> 方法，可以向实例的私有特性 [[Prototype]] 写入一个新值。这样就可以重写一个对象的原型继承关系</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line">    numLegs: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, biped)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>！</strong>Object.setPrototypeOf() 可能会严重影响代码性能。MDN文档：“由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 <code>obj.__proto__ = ...</code> 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何[[Prototype]]已被更改的对象的代码”</p>
</blockquote>
<p>为避免使用 Object.setPrototypeOf() 可能造成的性能下降，可以通过 Object.create() 来创建一个新对象，同时为其指定原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line">    numLegs: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(biped)</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123; name: &#x27;Matt&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person)) <span class="comment">// &#123; numLegs: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、原型层级</strong><br>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，在原型对象上找到属性后，返回对应的值</p>
<p>虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会<strong>遮蔽（shadow）</strong>原型对象上的属性。即使在实例上把这个属性设置为 null，也不会恢复它和原型的联系。不过，使用 delete 操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象</p>
<p><code>hasOwnProperty()</code> 方法用于确定某个属性是在实例上还是在原型对象上。这个方法继承自 Object，会在属性存在于调用它的对象实例上时返回 true</p>
<blockquote>
<p>ECMAScript 的 Object.getOwnPropertyDescriptor() 方法只对实例属性有效，要取得原型属性的描述符，就必须直接在原型对象上调用 Object.getOwnProperty()</p>
</blockquote>
<p><strong>3、原型和 in 操作符</strong><br>in 操作符的使用方式：</p>
<ul>
<li>单独使用。在可以通过对象访问指定属性时返回 true ，无论该属性是在实例上还是在原型上</li>
<li><code>for-in</code>循环中使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Jeff&#x27;</span></span><br><span class="line">Person.prototype.age = <span class="number">27</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：如何确定一个属性是否存在原型上？</p>
</blockquote>
<p>在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性</p>
<p>要获取对象上所有可枚举的实例属性，可以使用 Object.keys() 方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组</p>
<p>如果想列出所有实例属性，无论是否可以枚举，可以使用 <code>Object.getOwnPropertyNames()</code>\</p>
<p><strong>4、属性枚举顺序</strong><br>for-in 循环和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异</p>
<p>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols() 和 Object.assign() 的枚举顺序是确定的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分割的顺序插入</p>
<h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><p><code>Object.values()</code></p>
<ul>
<li>返回值：对象值的数组</li>
</ul>
<p><code>Object.entries()</code></p>
<ul>
<li>返回值：键/值对的数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">    foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    baz: <span class="number">1</span>,</span><br><span class="line">    qux: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)) <span class="comment">// [&#x27;bar&#x27;, 1, &#123;&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)) <span class="comment">// [[&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 1], [&#x27;qux&#x27;, &#123;&#125;]]</span></span><br></pre></td></tr></table></figure>

<p><em>注意</em> 非字符串属性会被转换为字符串输出。这两个方法执行对象的浅复制。符号属性会被忽略</p>
<p><strong>1、其他原型语法</strong><br>重写原型后，构造函数原型的 constructor 属性就不指向构造函数，而是指向了 Object构造函数。如果 constructor 的值很重要的话，需要在手动重写原型对象时专门设置一下 constructor 的值。但是，在对象上直接定义属性，该属性的 [[Enumerable]] 为 true，而原生的 constructor 属性默认是不可枚举的。此时，可以使用 Object.defineProperty() 方法来定义 constructor 属性</p>
<p><strong>2、原型的动态性</strong><br>实例和原型之间的链接就是简单的指针，而不是保存的副本</p>
<p>实例只有指向原型的指针，没有指向构造函数的指针</p>
<p><strong>3、原生对象原型</strong><br>通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法</p>
<blockquote>
<p><strong>！</strong> 尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。推荐的做法是创建一个自定义的类，继承原生类型</p>
</blockquote>
<p><strong>4、原型的问题</strong><br>1、原型模式弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值<br>2、共享特性。原型上的所有属性是在实例间共享的，这对函数来说比较合适；包含原始值的属性也可以通过在实例上添加同名属性来遮蔽原型上的属性；真正的问题来自包含引用值的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">name</span>: &#x27;<span class="title">Jeff</span>&#x27;,</span><br><span class="line">    <span class="title">friends</span>: [&#x27;<span class="title">John</span>&#x27;,&#x27;<span class="title">Jack</span>&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">let</span> <span class="title">p1</span> = <span class="title">new</span> <span class="title">Person</span></span><br><span class="line"><span class="title">let</span> <span class="title">p2</span> = <span class="title">new</span> <span class="title">Person</span></span><br><span class="line"></span><br><span class="line"><span class="title">p1</span>.<span class="title">friends</span>.<span class="title">push</span>(<span class="params"><span class="string">&#x27;Jerry&#x27;</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="title">console</span>.<span class="title">log</span>(<span class="params">p1.friends</span>) // [&#x27;<span class="title">John</span>&#x27;,&#x27;<span class="title">Jack</span>&#x27;,&#x27;<span class="title">Jerry</span>&#x27;]</span><br><span class="line"><span class="title">console</span>.<span class="title">log</span>(<span class="params">p2.friends</span>) // [&#x27;<span class="title">John</span>&#x27;,&#x27;<span class="title">Jack</span>&#x27;,&#x27;<span class="title">Jerry</span>&#x27;]</span><br><span class="line"><span class="title">console</span>.<span class="title">log</span>(<span class="params">p1.friends === p2.firends</span>) // <span class="title">true</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>很多面向对象编程语言都支持两种继承：接口继承（只继承方法签名）和实现继承（继承实际的方法）。接口继承在 ECMAScript 中是不可能的，因为函数没有签名。实现继承是 ECMAScript 唯一支持的继承方法，而这主要是通过原型链实现的</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>ECMA-262 把 <strong>原型链</strong> 定义为 ECMAScript 的主要继承方式。</p>
<p>每个构造函数都有一个原型对象，原型有一个属性( constructor )指回构造函数，而实例有一个内部指针（[[Prototype]]）指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想</p>
<p><strong>1、默认原型</strong><br>默认情况下，所有引用类型都继承自 Object，这也是通过原型链实现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向 Object.prototype 。这也是自定义类型能够继承包括 toString()、valueOf() 在内的所有默认方法的原因</p>
<p><strong>2、原型与继承关系</strong><br>原型与实例的关系可以通过两种方式来确定：</p>
<ul>
<li>instanceof 操作符</li>
<li>isPrototypeOf() 方法 原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，就返回 true</li>
</ul>
<p><strong>4、原型链的问题</strong><br>1、原型中引用值问题。原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变称为了原型属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors) <span class="comment">// [&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;,&#x27;black&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors) <span class="comment">// [&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;,&#x27;black&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>2、子类型在实例化时不能给夫类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用</p>
<h3 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h3><p>盗用构造函数（constructor stealing）也称为 <code>对象伪装</code> 或 <code>经典继承</code>。解决了原型包含引用值导致的继承问题<br>原理：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 apply() 和 call() 方法以新创建的对象为上下文执行构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承 SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors) <span class="comment">// [&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;,&#x27;black&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors) <span class="comment">// [&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>1、传递参数<br>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承 SuperType 并传参</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>,<span class="string">&#x27;Jeff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ins1 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(ins1.name) <span class="comment">// &#x27;Jeff&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(ins1.age) <span class="comment">//29</span></span><br></pre></td></tr></table></figure>

<p>2、盗用构造函数的问题<br>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能只用构造函数模式</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p><strong>组合继承</strong>（也叫伪经典继承）综合了原型链和盗用构造函数，将两者的有点集中了起来<br>原理：使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例方法。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承属性</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name)</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ins1 = <span class="keyword">new</span> SubType(<span class="string">&#x27;Jeff&#x27;</span>, <span class="number">28</span>)</span><br><span class="line">ins1.colors.push(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ins1.colors) <span class="comment">// [&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;,&#x27;black&#x27;]</span></span><br><span class="line">ins1.sayName() <span class="comment">// &#x27;Jeff&#x27;</span></span><br><span class="line">ins1.sayAge() <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>

<p>组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf() 方法识别合成对象的能力</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>2006年，<code>Douglas Crockford</code> 写了一篇文章：《JavaScript中的原型式继承》。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。文章给出了一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ECMAScript 5 通过增加 <code>Object.create()</code> 方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）</p>
<p>Object.create() 的第二个参数与 Object.defineProperties() 的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jeff&#x27;</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">&#x27;An&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// &#x27;An&#x27;</span></span><br></pre></td></tr></table></figure>

<p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但是，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>与原型式继承比较接近的一种继承方式是<strong>寄生式继承</strong>，也是 <code>Crockford</code> 首倡的一种模式。</p>
<p>寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">ob</span>)</span>&#123;    <span class="comment">// 1、创建一个实现继承的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    Fn.prototype = ob</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> clone = fn(obj)</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 2、某种方式增强对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone  <span class="comment">// 3、返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    friends: [<span class="string">&#x27;Jeff&#x27;</span>,<span class="string">&#x27;Ann&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = create(person)</span><br><span class="line">p1.sayHi() <span class="comment">// &#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个例子基于 person 对象返回了一个新对象。新返回的 p1 对象具有 person 的所有属性和方法，还有一个新方法叫 sayHi()</p>
<p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。fn() 函数不是寄生式继承所必需的，任何返回新对象（深克隆或者实现继承的对象）的函数都可以在这里使用</p>
<blockquote>
<p>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类型</p>
</blockquote>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。寄生式组合继承的基本模式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = fn(superType.prototype) <span class="comment">// 创建对象</span></span><br><span class="line">    prototype.constructor = subType <span class="comment">// 增强对象</span></span><br><span class="line">    subType.prototype = prototype <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>寄生式组合继承可以算是引用类型继承的最佳模式</p>
</blockquote>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>定义类有主要两种方式：</p>
<ul>
<li>类声明</li>
<li>类表达式</li>
</ul>
<p>这两种方式都使用 <code>class</code> 关键字加大括号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="keyword">const</span> Animal = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>与函数表达式类似，类表达式在他们被求值前也不能引用。不过，与函数定义不同的是，虽然函数声明可以提升，但类定义不能</p>
<p><strong>类的构成</strong><br>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必须的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行<br>建议类名首字母大写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有构造函数的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有获取函数的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">myBaz</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有静态方法的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">myQux</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过 name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">identify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Person.name, personName.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">p.identify() <span class="comment">// PersonName PersonName</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.name) <span class="comment">// PersonName</span></span><br><span class="line"><span class="built_in">console</span>.log(PersonName) <span class="comment">// ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h3><p>constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数</p>
<p><strong>1、实例化</strong><br>使用 new 调用类的构造函数会执行如下操作：<br>1、在内存中创建一个对象<br>2、这个新对象内部的 [[Prototype]] 指针被赋值为构造函数的 prototype 属性<br>3、构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）<br>4、执行构造函数内部的代码（给新对象添加属性）<br>5、如果构造函数返回非空对象，则返回改对象；否则，返回刚创建的新对象</p>
<p>类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length)</span><br><span class="line">        <span class="built_in">this</span>.name = name || <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person() <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(p3.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，类构造函数会在执行之后返回 this 对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 this 对象，那么这个对象会被销毁。不过，如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">flag</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.foo = froo</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                bar: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1) <span class="comment">// &#123; foo: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p2) <span class="comment">// &#123; bar: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符，而普通构造函数如果不使用 new 调用，那么就会以全局的 this(通常是 window) 作为内部对象。调用类构造函数时如果没有使用 new 则会抛出错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = Person() <span class="comment">// 把 window 作为 this 来构建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = Animal()  <span class="comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、把类当成特殊函数</strong><br>声明一个类之后，通过 typeof 操作符检测类标识符，表明它是一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person) <span class="comment">// class Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>类标识符有 prototype 属性，而这个原型也有一个 constructor 属性指向类自身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype) <span class="comment">// &#123; constructor: f() &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>与普通构造函数一样，可以使用 instanceof 操作符检查构造函数原型是否存在于实例的原型链中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>类本身具有与普通构造函数一样的行为。在类的上下文中，类本身在使用 new 调用时就会被当成构造函数。重点在于，类中定义的 constructor 方法 <em>不会</em> 被当成构造函数，在对他使用 instanceof 操作符时会返回 false。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么 instanceof 操作符的返回值会反转</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person</span><br><span class="line"><span class="built_in">console</span>.log(p.constructor === Person) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person.constructor) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person.constructor()</span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor === Person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person.constructor) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>类是 JavaScript 的一等公民，因此可以像其他对象或函数引用一样把类作为参数传递</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类可以像函数一样在任何地方定义，比如在数组中</span></span><br><span class="line"><span class="keyword">let</span> classList = [</span><br><span class="line">    <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id_ = id</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`instance <span class="subst">$&#123;<span class="built_in">this</span>.id_&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">classDefinition,id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDefinition(id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = createInstance(classList[<span class="number">0</span>],<span class="number">21</span>) <span class="comment">// &#x27;instance 21&#x27;</span></span><br></pre></td></tr></table></figure>

<p>与立即调用函数表达式相似，类也可以立即实例化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;bar&#x27;</span>) <span class="comment">// &#x27;bar&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h3><p><strong>1、实例成员</strong><br>每次通过 new 调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加 “自有” 属性。在构造函数执行完毕后，仍然可以给实例继续添加新成员</p>
<p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享</p>
<p><strong>2、原型方法与访问器</strong><br>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 添加到 this 的所有内容都会存在于不同的实例上</span></span><br><span class="line">        <span class="built_in">this</span>.locate = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">    <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;prototype&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person</span><br><span class="line"></span><br><span class="line">p.locate()  <span class="comment">// instance</span></span><br><span class="line">Person.prototype.locate() <span class="comment">// prototype</span></span><br></pre></td></tr></table></figure>

<p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    name: <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected identifier</span></span><br></pre></td></tr></table></figure>

<p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(<span class="string">&#x27;symbolKey&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">stringKey</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;invoked stringKey&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    [symbolKey]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;invoked symbolKey&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="string">&#x27;computed&#x27;</span>+<span class="string">&#x27;Key&#x27;</span>]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;invoked computedKey&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person</span><br><span class="line"></span><br><span class="line">p.stringKey() <span class="comment">// invoked stringKey</span></span><br><span class="line">p[symbolKey]() <span class="comment">// invoked symbolKey</span></span><br><span class="line">p.computedKey() <span class="comment">// invoked computedKey</span></span><br></pre></td></tr></table></figure>

<p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name_ = newName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">        reutrn <span class="built_in">this</span>.name_</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person</span><br><span class="line">p.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<p><strong>3、静态类方法</strong><br>可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。静态成员每个类上只能有一个</p>
<p>静态类成员在定义类中使用 static 关键字作为前缀。在静态成员中，this 引用类自身。其他所有约定跟原型成员一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.locate = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义在类的原型对象上</span></span><br><span class="line">    <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;prototype&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义在类本身</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;class&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person</span><br><span class="line">p.locate() <span class="comment">// instance, Person &#123; locate: f &#125;</span></span><br><span class="line">Person.prototype.locate() <span class="comment">// prototype, &#123;constructor: ...&#125;</span></span><br><span class="line">Person.locate() <span class="comment">// class, class Person &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>静态类方法非常适合作为实例工厂：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age_ = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age_)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用随机年龄创建并返回一个 Person 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">100</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.create()) <span class="comment">// Person &#123; age_: ... &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>4、非函数原型和类成员</strong><br>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在类上定义数据成员</span></span><br><span class="line">Person.greeting = <span class="string">&#x27;My name is&#x27;</span></span><br><span class="line"><span class="comment">// 在原型上定义数据成员</span></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person</span><br><span class="line">p.sayNam() <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure>

<p>添加在静态属性上的方法，可以通过原型链找到，但是直接打印类本身是看不到的<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAYAAAGjCAMAAACIbecRAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAADGUExURf///8zf9tbH3t3d3enq7szO0fz8/Ozx+O/v7/f29+Hh7cbHyHFycvr6++Xm5bOzswAAAJs0e6Vyp8Kjxv//2HojdlVXWbOEsdXV1aQUFAFquYKDhuanVI+Pj+f//xsbG8j//5NVlVKm6ceAA//IhQBVpQuBxofH/6ZVAKfj/5OTk/3kpoMAAI+14bbT7J+iqAAAhSQmKUeTzWSj1Sp7+ooDU8F62J832RgA/1IAfLZrnrKSwAAAUlICAdyo73d6wv/H/87Pl3Xa/o0AACAASURBVHja7F0NU+JMEo4bDcklOGwVm9oDIhZgUFx0D3yBt27l9f7/n7r+mJlMIqIorAt0lwoZJp/STz/dM93jeZ53FomIbCpJfPbdV+fnp6dhGMJ2vR4E3sgT2Vc5ExHZWAwMnAsMHAgMyCMQ2VhcNhCFAgMCAyJHDAPCBgQGRIQNCAwIDIgIGxAYEBgQETYgsQGBARFhA8IGBAZEhA0IGzgCGKjPTtd3yLrdbrzBGcM09eW570DGrdbd2g5T/vhkWi/+u5NWXisd486r5a1WfrLuQE1hA8cGA9EsWq/Vie/FafjmE0ZJ7AXy3Hci041hwPNqEwcGTiaTu3LL62xAYOCwYWA5nwMEfJnV9cZ8CZgAbZ73BTa+6F7fk9Dz4TfudgEMMpV2kwg3gCFESbervDjLuo79D5NQnvqW5a7FNh31HOx7a1Knlyl/Yg37dJy3xvhBqzWuTSb5uDU2MFDLx8QN7qYbwYCwgYOHgSXoP/xzl0uzMfuCP1WCEGeg7qjs4B7EUZKGoOes6tgM72KAgqzwGuIkkqe+XTkxemvYwHjs3U2J809dcj/Na9iV2ADo/XSCnVwYGE/xEOgUTCU2IDDg6jppPgYIIvhdzk9pa1bQStVFk4+Gv5uRh0AAgLqOyBC1fZVE8NdwhzSTZ771oMDYZf1TNPbeST6p08ZdySmoWRiY1KZ3BQxYOGEkqU/GwgYEBkD+xaoeUYQwMt4BIAAa+lN0DVjY0Guq77e1qfdB3ZWiBujgOAIFIojsBAbuwD2ghudA8BoMjNFdYCIwfhsMvIkNLBeLh93dfPO60ZOvwA5hINKkoL6sw1/Q/LpnBw5ODR/Qaq1pQGxtPei/IncBO1h0EBjYSWggd5yCu0mdGb5RcNToWj51YADbKzCgdzF+RS2/2yYbWL4BBjqNRuPXzeY337m6kG/ALmMDFCGsz+boCMzms+VMxwmxaW5GEX1t6GPyDZAAeOQhpL6OEFL4sPAEHEQQ2RodoBAhegP5CQ4BTsdk2cc89lerwAB2HGsYwA4YUXRh4CR/beRx05GCN8EAqPPgHTjQFy6wUxgIvCAI3E1v1UBf8MJWsLqDiwgieytvZANzcAcuLAw8LRaLITsJ9AqfLi5LMNC87iHJb+TI9Yd9YgcDYAmo6X0iC81v/3tslOy/wMBuYWA3IpOHdsEFdiDjj8cG5qChZEkYBsaIBJdepHW/QhEMDPRzgwb8/q8b+3Hn52XzB/4OBQb2HAY8mTt0LGxg+XDxzCmY3wAMsBYvHSrg6Pk3aB1cXTSvc379QWpOqg8MgVDB1Xxok3/HPsKAyOHAwFo2MHsoxwZm4AQsbsg5IICAbUefMUT489K7fYTXBsKAVm9ogGZS/xUw0H9PVFFEYEDk97GB0juy/vMbjRAX1m1w2ABq/d+Xz6x8RzsC8EfYwKHBAE44kIDh/rOBF2HAsH8DA6D6s8VNyV94DgPkDFTUewB0oI8+A5CEKgxIbGBPYCBKQNdHz+KCmfI4zwgl7soU44NjAzQ0APqOIwI4gQhee8AGcKCAiMGiNK3IjP/jSEGjZ2FgYKYT9BvWORAY2EMY8NMkep5PxDMMvDOiA76kGx1gbIAk2HVEWGDgD4SBMMXUAppMlOHMQviN220fJw1R8kE8SpN2Wswr5FfxDQ6SDfwW6eTy7/jjYIAzDLD+gFLI+HFOscpi0HMFtD+LVRqnCjyETGnYIB5gtkQOjg3sXCSn4A+EgXuaHJTF5PUryjBGEFCUWgDUQGV++zwJbWYB04RY/g/CBkQOKDaAFQcom4hSCfyRF2Wh327HaPbjJBr5SoHq21gBhQgkz2Cf2YDAgMDAChxo+/ATpikWJRpFXphFuAGK76cJEAHyEAwMnFJiosDAIbKB7/KYjhUGuAYJvKQKVJuyj6ksEcYFoA08grDtIwPQ5Yg4KKAkNHCAsQGBgWNmAyzBGvXGz85onoDiEYJMYgPCBkQOEAZQubvrjLw7h1AmDwkbEDlQGBARNvAxoSkBHTMcKCODAgMifywb+CAMDFC5V84BwlQCnWJMoCDVxgQGRA6UDQz+88/FKhgIjP6bnEOZNSwwgOFGnJLAG6PdFTDKXg1TqJcCmn66cajT3NK+zaZ+V2zAlBPrULIQ2Xr4M7jqDwkGdHPr+pd6RMNvoUHrv8DAwcLAiq9/sHJ8gccUcEIyFzxF5VHdDFSvu534ojlt9vyKSrHOrMtLMHExNRrjsPkRm5RXg7uI7S3ZTMsDZgOBKSd2OyaCT8a+n3uDq9sJqrxuHjSG/Z8+dC0yjQfsDQgMHCwMrFL5VcOHDlyAxvBetPwRF0HfwpWsU0RnelOm4FIC053Lsr/TlJd2O8v2EgY2YQO6nJgl+h0uNDi4Cr/eaMsPzaDz/R62G9QwXoHUF9lbGFBkt3l1Q3Wf4EuRgggbWve+p84ihzyxEHcFNdelzt085TD5zgkJBAY4/wh+fTqC377HpRP1KegIUVul3cy9IFxKzS60iKwiw964LDO8KGoJE6VnQdGLw0/ggovlWWilJqzKPsJTwFm5goJDT/Q9812M7rujlOZR8QWV4I6RRu3LwOm7YgNcTowLCmC5MdB5rjc46CEkcLOFgdu/b1waIdXG9hYG+FvN6YaYQIS5Bm4KolZvSi9SzxUCl0TkdQ5UVsKWgkfjEeFY+ggxr5SQWbbNiyoWxhzXUUvMQou86qKnF1WiTmFM9j0EbeWcSMYpR2HPutqZT4oE6YxOEYd0lSV+w/fMazmeJ0mcxpldxKm8bovOtNw3GNh0pKCj6wihgccS5EMuO/oty02zsIFDgwG9oGmbZxRnnEmg0O6bNlZQtMTF959Ui3alJCS9RmrJi0fLn2kPnddR5iOgHgbwOX6kjxCmccG+OcsxZCqvV13E4ELXTmUK6IrQyTc5kSGdpYChGHv7uoF0nk6B109XGbvpknzPdBdJiM5MnJnz4VnUSr/jYNmAp8uJoeWn+CCOEZDn30lz01zAgMQGDgMG+KtNmpTFdg0zbYtJa8h+VpYzy0zOIbQTBKhKD9jCPqS3fArzuUaLwFCASNc7UQ4ugcI611V46LoTbTLy6N6VpdizWGX2jDZCiHvbq7AOjr5nvoswo3QKi0llxd+ztIr3xAZMOTGsPXyPBp6DBajkt4+5abYwUMwTkJGC/YYBNqUJ8fbQrmGG+YfcRkQ+tsG5jPg2ooNPngAzczCdZRjw2+dp7CisDe8V3VD/7RHwiJYhoB3nnfSqi2eah+jKJ8Af7mlwEi8yZKvvxvKQ3FuV5/MaugL9lQUHMvX6nukuQP9DSq/U5ysPiHBAJN6blVy2Mm+goP1VoRWyZN7AocQGnAghfv0pQkBRNx2diyla5nNIT8OAjc7BDsD526hwjsqEhlSTJdbKy0fQVttmOeIRDJdQXA6lm46UNfzcT48AxuyYxLCB2o3H4t7u2cmRcCokKAor6lPAhxlXXzOMX98zXHIGJEJReqUdcSw5Onwf+wcDH8op6L9SPqw6i1Cqje0nDASvNnBr8Jpn4ZYs1Ta/xBBer3tpeuBu6y8rKPsflTNp5XUJQrD6fEHl08pykCVPQ4dA473JsNoCG+g3Xp0cLDkFBwEDHxZjOVe5zqq78VC7tv+b9V6ZKPnRlRjN5CEnKkrjE/sYG5BEY4GBnUuwhkZ8/nUdq0i9AYEBkaOX98QGBBYEBkSOng0IDAgMiAgbkMd2NDBQjn2JCBsQGDhKNiALkR0ZG9gtDDR/NFYlFb3QjILDjIN//9dszi/p5YmWT92p4FzI57JcPFQGRmc8ESJaLIo7eLKdZovNc6j0OZr9v074EfQ+HQakzLCwgS3CQLB6smHw4hxEnnQU9RkHcNlk0ro5/u2Y5ZG3KmZ642oYAMUuKeXMLOSsF3WnC/sgDNhzDAgH7ATMz4OBSoaAiMQGPugUvKDvLzWXNGDee3rQphfBAdMUBlvHgddmOT89uPr6cKH5yfxmJQy8T0rnKCZgfx4bKCXOiQgbeBEGdFEyzCnCGmS9fqMx5HIEaNB1s61a1OFmSwd0c5/tOzgJ/KY05fhpcfPU0+8MDDSve+ZgmOpMO5nyaHyw5tf4R+lc0Iyf93sdvsIf3HtAvZFh0JX2dWvesQfjNyUVBQ4wvyhgALnBYtGDPkt8QU+BnRegMQ4yuA/n6qL5ddTI+7htH0oFBmw61s/Lz4EBWYhM2MDbYECbZTTfmGvYAZVBNdV6bJqN2UeuX6pNzM20B2cv3z4On1UlmC/GvQobQBjQB6Ppyf3cEgt9sOb1rxsCi8LNaF6Tnue8V4+uDuuikAdi2UCfwSGnZrNXRUXBjX+4WMEGwFFgqOIrRZLvTJE3D2eACdi95vXV7SOWaikeShUGTHL2J8FAIAuRCRt4EwwYRaOvMXxrUf2pNhl/c02z0XesUOL6AcwGyAUA1SfQwANWXQW2sYZ0W9Dgg5GaYtkTLo9mD4ZQ4rAKTIHCPXVhlNt/uF4qxuGoawUGEGrgKsxeRrGt16zNvGl1nAICBgaDWdlJMA+H38NZYQPaiocSVQKgm3oF22YDEiE8NjbwXhjQTjzpmwMDmlybZv09pxJlpfAeN/NnQ1RoqlpmS5dZPjAEOxvBb6BDhOQM8MEsdeDyaMXByjBABKFn1X2gvQAi/Y0XYcDsRTpa4gO9Oejs3Oh5FQYi6xQMn8MAekoNCwPuQymfY00S92+BgVLinIiwgTVsYFiwgY4DA1yP5P/sXYtW4kgQxRDMGtgDnRAiwniEZMTRAVdxdFZ2PDP//1NbVd2ddEIioOAjVO0uIUl3Q1zu7VuPdPThFOo52WmoAXiJlB++9PN/OHtChKVqwPhoc1BErRosTwOIe+yoaUC5Jln0L9GA7rUU/rufHGEyoEwNJPP6kcED6o9DsmVo0MAkDRGefhw1wMVDHBtYOzag1D+69AhAkwZgFtWHkyCA9nLjzrkx36FQB3Anv/o8XRzdnT7cZWIDxkebjWO1SiI5/5oG6LOSVgrueoXlJOWQXSZJ0UAGolli+vZEX0bFBp7uSmhAEgRFAlMamGBaMnEKkj9KaWxg3bQIFxOzvYsakBJdZQrG6S/9Qsbd9eFY696hml0lDSSHIxkrT8LymTDi7586Sf87QwNqMA1VvTyaGixHA/KzMDYwVjrku3QGYulikI9xLnMV8BVMNdBZDt9hIYOS/RKhhw8yUyBp4OmnPP/wUwU1MjRAmYEvKQ0kf5SyTMFw3SUamAbY3kcNbNNIDVBcIFc5o+Fx9PIaQmIFM3NQsnhOaa+8GjjTqiDT/XV3rpfUDcTvrQaEqInkLVlyhlHEamDLRok7KZHjTI7saVwrAt1GNIDEQtnIF/bKVhH+zsYGt2SZz1BVhLBZu1SqsSMSEIR3keJe5FlAiBw/sH1KNfAhbi2KOkl1UfGaha+4pyBWGYGX9Xoq++C/f/7cVj1j/jPe456C417PyA74j0ca7UKB3kB7EfTx/dGjz9hiNcD2XrYNNWDWCuRoIKcGRIFjwDTAsQG2z08DmVoBKzQnfZFXAyU0UAst/l9RcTXAVm0aKLyNQBTGAgvYgWMDe6IG2CruFFwXrNadhAgzysBUAwx/VgNs1aGBdrsglUoJw6UkIdNA9dQA0wDTQK1koRFhAF1LgrxTUCsIFLBVVQ1g8R0/mry6NFBwN5GsHRJp0vBZNcA0sCexgY3XxGH7PDRQvAapJAL9wjTAsYFarSu+8Z+umjRQzxQPZZ2CpKQ4DRGKFbVEbBVWA0wDlaWBw0P+G7IaYBrYe6eAbb/VwAaZgoifTM40wLbnamCDZTDY3pgGDtjYNrUXxgYuOGP4UWnAYWPb1Dg2wDTAxjTAmQKmATamAVYDTANsTAMvyBRwFSHTANtrTQhHJG/JPpMawHsKOF/INFBRm96Rjac7JwFAvfxXvTjvTwO83gDTABvY5G58BwwARLAzHvAfbY16ocBfqAamJyezZweay9OzWzs5ZN+enLuZMbDNfNVIvN7AXtOAPWg112/tjnzHseDn+mgbx4Sw4KctRKgarA+H0saWZ6/qfNkarGxje/CdFtbz19RqtWGwtt4HFgACOIDN+I1o4Bk1MN+YBuCCbg0amN3eQpv5dBtqgK0qNDDotfCf6xRM7Q1+vkfWSELKD1OkPdIhS/6ydYP1KMgrbWx8QIm1L9f4BEt4tuu5z/Mg0WDji0LS0R3ywB297ogF/rLCdP5XGiCnBmYnck5HnMP8fgI4x82czqQT+xz0whRPwMa9vT2ZngDeD4gG3PMpaYMZDJGliRerAbZq0UCvlYDgyzGAJQwDmtCDIPCtxcjzYM8SdMzNiAUFdie0pCjAzSOhLPQzDUxEB8HIdSx69RcebtxREIROCB8HG3nMwjYhjhoEloVn8p2ctjn7K/RmMA+dkqvA3jCq51kgLGwvgItZLAK4Nhjj0mSQ4wF9/3aqBgD+NWeMPLDzEGFZNGCmJ3StBqZTZzaXmt/UB/NzF5sSzAH389vpXKsBSQOwTzSQ8xRelilgqwoNHPd6GTXQQBBYgY/A9gEioeULa+QvEDyk2Y+LfAZUAAh437doDrNCkXUUTBYgeY+whOH8wEIJEFqG8g8FHkMKgAZKTUidoDrJBoBekwYUek0tLGd9eRUujAND+n4II9uej2c9rwnfFKbVweWyqrhMLnN8N5lNKELwRjQg8sqAUG/QwBwne5ABNKfPTScfTrsJDdy68xlyxUHqFCBHQBuMD0znrAaYBpJfvckCrnSvfZwvCWqAHgAOIMbFqbrUP3dBAYQK+NK/dx9LJhsJToIxwDIM6YAvpCMRpp4BDhMmBEG9VKci1+G4BVdxmXcx8Puqq4CBJN9YIXAVnMCLsuBtztlowzhEdG4yHMqAGUUIxjunAUwYCicTHlimgRlM5HRgmQhMGjjQNGDEBqboLpzM8egKx2Ct2MDVL76RqCIhwi+93sCIszWlxAfcIfQAMAsEC2LmOZf70VYhgVxoYNnqxCUEa4lMS4IVVT4xiJrE4TuAEtCQp0aqU6FvX+AToEMhWUYqGct37FC6BSE6LW5IRJDr05Cqwk3FBUYGDg7u3kANCJGCX0sCNYufG04BAFgqfA1w5AT3fG7SgGuoAdMpkG3w/HbUQGw+Xpjt89JAozdoZGlAgRMAZAkSAlY6BbutfAgRoIWBAE0DSgZk4GV2QmHv0PwM7wijYaL6KZ4gPQPYd0cjN0sDspNOGrRbBh0o2DZbx7n8grwKnP0X0Cq0cVT0DgIQAnRtOeeieWluVKZg7MwmmCo42n3tkEiThiKbKgQmQG/gZIYpwPmUZvYpoFsGDzM0gA2nigawAaoGkwYwrrgiSrhmpqAbnDHCKpcwJDTVVXQuDEbSI8A5E0N1YRENqMwgRQjDRAaEVgkNZCKEKuBAQTwZ0/NsJdP9QKBXTxFCZACMT6pOobNMAxq9KQ3IMKC6CkU/dFVADaMgDFORk6EBFRO4bmeqhw5qf092WDeQugHCeHm/2qG11cAh00AVaeD4i/3Kn09RaOA4O0fvwLRP0C4tHQjXS1yqSCMlTMz6obeoInSUC6BKio0QoXTpt23TLWQKmAaqSAObFQ8VkABFCd2RsDJ1PbtmgUsZz3PLCohAGazFAq4MD5rFQ0mJxJ7VTq4ZG+B1RqpIA2xsm1URdi/+YT3ANMC2z2rgsPuDM4ZMA2x7rgY4NsA0wMZqgGmAaYBtL9QAZwqYBthYDXAVIdPAqiTbyApDKiIys4R6tQE4qBqwVS82cPWLn2TONCBp4FGj3KjQMUuK0wZslVMDbBWnATf0ArnMQOA7ljcaLQJLlvvCud61SQPqBgK16AAWEJklxWkDtsplCtiqTgMjX635g3f/i6an7tDFY3WDBlIL1aIDIfoC4A2gnyBYB7AaYPvENCDv/sOFgYRVlzcY+XJ9oBLDlUpE+Q1GbBXMFLDtBw2AW49qQNHAs+IeaUA1qDMNsBpgqxAN4D3GWg3IxQKysQGdGrDlSmSyAasBjg2wVYgGLBF4iRqglQGswthAXQjfSfKGrAZYDbzahhtlI7v96es/stv3MnUQ8Y8DThi+3v5iPFVZDUSdTmfrNxgm9y4zDVSFBtgqrQaicwDrtnngZUsYHHb7s+1jJxZnTANsTAP2Khrofp8Acjudc3yecf17B6uLh6ASJniqg7vd4M+vjlF0jIc7/30DuEcdXNk47tAGewGloMLodMbYSh4dR8lgnVULIXcf//QXUX9GnGAQQ7wY9kktwAYm+DiMfvzBiT+m3dQN6fcXUhT0c7KAaYCN1cAKGoBt92JM65Xjrnq8OR7qXsCp7/+c4WGj19Uv4o4xvf/3Wy0G/ON/Q2QNrQbkWgZDaIWHVa/n7SjyrvrT4aIWLTJTeQzwxt2rJxjQO437s0jUxcEVUkJmwh8SDUTTWuWMaYBtV7EBoIHo6yndZhh/PSWYRmMNV8Q1UgLBORqnYmCSMAT2Go6lIxBNJPLzNHAuB1G9zLDEsjjoRrMrcQZYhlcTzDHM7V0h5304BbvRFPaHU+qyTAPeKdMAG9uaaqBDqv/qV4feKBVAMh8O092HBTRwIRWAhrv0AiboWBCw9fHDLA2oXqvUgKIBAHfXmOY1DXQjkPspDeBev79MA0dRfxeRBqYBtqqqgVpNOwHJlk59PSU1AC85GiDcj9NQoDqTioBCNaB7rakGAM/xorZEAzjNG2pgWfwPdaerqvEA0wDbDmMDan7P0wC4893vY6n+NQ10LxC3upWGe6zAnKQc1KhZGjDHXkMNAOjFQQENoE5IaWA5H5jQQJdpYKWVFxVb3noPOrDvn3+grjO4ublpMho/fqZAIpqmag3VoSonwOD+eS1PA3IiH6ezfqyaD6WLQd3GdBSne1MNmHKgOFOQ0EDWv9c0cAU+QDulAcwU9FPfgVyG/oISBf3pvjoF8iHnrevX0EB9TRpwV9CA22s4zZ7LcPzQamBFKj+31XL7X4ocbrii8ca9lgT/4Yp9LiY2aaDX0hO2hysNyFdnsaANPXkMlyAI8OHidMz35QMI4ZTnekGQdlINcncg3D883NuOdU9PKoSdB9ex4BVGeKIdaQ2gAPwPRMEAH352cwNjXINCaMBwqBOuL1s3TBPvHBt4WUkOzfybFh1t2qtChT9vTAPHvZ6pBujBovSUUnwiuGerR48masD26HnBigaUNyA3spNqkKWB+3s5whOxwBPKAqUMkBmS4uPmwLHhmwyawAFuA6gADjRaOHa918R31zdNu8Vhj4+sBkrn6ReVIG/UK+5Xpwr4zWMDbZMFJOTlRO+rZ53bnlxvUNGAfk88YaVOgepkFzwM3b2XTsO9pXYQ/PdKGtyn7XDiv/6fvWtRThtLohqBwRFTASGwwlqbCiDjOBg72aokNTgZV/7/p/Z23+6rKyGJh4UtRHfNBtDb1Pbh9Ovc7sU3zBD00P8VnMAK7I+PsMiYdw0kQdjACbIBsbqnCP97hZ5WCAPw2XfLYMDdAgPuDys1AB9+AC3wfuJm9+e/JkDpESfokudrjvANCYLaDkxAswOxU2MDYjWHgYura3N0e8hBgTd1DQzo4WEUJ2MYCLuBgoZABwUtVCTQJzEM2EGBzgkADLSDtoKBf7XnE0lwmQ8Q3+9rR7/uWbHC9aO6YA+YQO9avPVtKwVizS8YgvxYQP8SDEByECVJp5gidOmwIbwL9a4wOYlhIKVOoDOEkBv0lPP//PHDpTyhB3vsDCGXDS8IE1pX3yApqDOEECc8Poq3ChsQO8n2oUudBrzEdOAlb7pM9ohJbkBMugjFhA2ICQyICRs4so3mTwWVRl1qjHR3oagPiQkM7DJhWJ34UGY9xN2mCA60dwgDy2zXME8SLMn9BQbEBAZ2mSmoToTsNWFgxL3Go1TT8ZJ6D2MaSBARMjGBgV3Vh/YSIRv5vXvgEEaETB+tRQvUdniz0JpjA61mBPfgs2jwKHsxGmMa+V8GizncO9qRp7ybr5IYwLh91DzdEYEBsSPlBg4SIcM5QzxDi5ChABlqEiJUIKzczwwbgHuAaIE5a+ZkLoaiROtPCBafb5a/Z9HCKJrtRgvA+5XnRxM9YajVSFYCA/sbr2RyDIP+JbGasoH9RchgwFgdTSJkl6gsBrs1DKDzwluCARwynpmzls8ftQaBdTH+OJ+pj+p49ZkVzcgirXBUxAZAhww1yoQNHGo0dLwNBoK1e7Az2zCg3ssy6bVhA4eIkL1Dh4bf91vjyDYMLJwUDKj9ADMjOgtlCAaL1MXgFNxuYMAomu3EBrTOwHeBgZfDwNbDQreS33RvLTBQKzbg7CtClrCBWw4d9D8WG4gSGFBOHi+SszJ5RGYDREQSGEj/8pezgUSVVGCgnPKjwoA7HI7Vjz6oCbi4bdg22gOwoxs8+bDgMfQSQwfytTX7E4Te2vPWaz/wA1jpEFY8ZBzBRZBD35/yAWqv7xvQCPR7F9dFUzCwI/CIvUqlwNlXhAxcVO/SbhmRODmJiqB2OeUF9dW/X9ln3c+sFEMCA6BynrCBHesX8YMuDUZcEBAY2MbK9ZqmPG04dWGWEEaMyClx8ChQjkyHwnzBdXYE0JsG4boXwhVosdNu9xJO0pjghtYB3johDzDO1F5LgqCmbKBAhKyjs/edDRhIS5LC4Zq+R6ZSMKPQQouWoTIZnYUXxTJECgYgPrmxcgNG0azcWIE4ovVJBAZ2gYFQf0ACAKuajrMwQEPHQYEmoSIEoQvro4bdwLWiCnBxWAQ1pAO8qe9bdEBPMYe+4EDNcgO7WUbta+/FyTCeOGxJM7EqYQDCAOXXBAN64JipeQ4MBAAT3RIYaIdewDBxqWEAMgeugYF1Ot9IYgYCBDVjA4d17uzp0BgwCAzUAAZYYUzn5rQ6GZcGgjALA0ZuZDMoIBhQBwbdNBtw1157zTBAt8jCQFeyAqfIBrJJub0cOqaAQWCgHmwA8oHk8VPkBhAVuKQ9xcZp8gAAIABJREFUgIHCsJ2wAaQDxTBgVQ2IDUCKMDAwAFEBJw9gjw+3gByi+OfJswGxk2UD4T49PEgMwqIf7kuLVxQfIHYKlQKxM0sR6l/+HS3UycNCP3eTX3oxYQNizWkmFpPcgJjAgJiwgVraZKL+Z96TmZ0CA2JiTWcD5PET8vdJxvsnqSOzGCEwICYwUBkbmOevQTovXJo0mSA83LhBmGCAXm1PL3J8/DTSg8bRTGBATGCgmkrBfLbP5pjXN/51Vx0MbLKAiZMfGtgwYEkbCAxUaUWrC8jiIw3ODewFA9r1YMgwfgEO4FjAZJL+yU+zgRIY6BhVwmNKoTUcBsLi4mKvcMWxa1l95ORyAywzpl/iRaR5flqEzPj7hjCY2YwzwPOBnh7SIQHAAM4f01nzWZS66BzJghEhK84OFGYCS4OCbQgmMPASGPCuLg7YJVZLNtChqV9WG4sHWv0rI0LGvrQpDGY2w88+KpEsTNswwwCfNVcXx1ftlvA20tpkCBZbYWCywQ3SbKAIFOKbjwID7Ndj0BMgvQEtJ4CDxoE3HPpPY5hBhj1abwDECfAT/pte17yM+stiZKfGBsipWW0MPAamijMiZOzvGWEwh6ePSYQMZY7pComfm7PmpEQyN4qFKExki5AV1wpsp88pFk5KSodNiQoq+o2F+WDSG8A5YoKBaRAOeyH0D6sNpDeg2QBNIqaXMExWJd20vqxQfGK5AdIbYLUxhoGMCJnx9w1hsPnMEiHD3/YZq4+waIE5a27kRiA2wNvsAgObBcNJflBQAAOdNHCdNwwE2B6cTBgmMDDEWSAkAGa0SMOAXgM9mwAogQFZqPzUKgXkf6w2Fie/5bYIWcrfN+JuI0IWk1CIxQYc6ywrRldsw+iWl8PAZOJswkB+ilDYwHYmgGIADANaTiANA7THhoFcICiDAakVnBobIPbPamM2DFgiZOzDRhhs+ZvibbM5UShN5QYc6ywLBlATHWIGEjTUKqaDRXFugKOCyf5BgeQGjLWmXnvIMEByAu7Uc32GARo/NDAQWLnCvNzAxTfcdo3rl3tX15IbOM1KAQiGUaVg4RgYID7Pm/XKI7NEGEzDgL351x1pC7MeaQIDfBbBAJ4103WFr58sgfLRfb6/GjawOwxMpFJQlCL0n2w2AHQgHE+fGAYwLRgYGMCEIaiVglxJKjdA5YAPNgy0NAxIpaAJfQOd3LflByYkQEcIJS07xddkXdQ8GJiY0YLJLrmBSQNjgsoLhuVyAttM+gaaxAYqNHR+HWXEByyLGOXHBFZlcOJkGogy7UO5FUPpIiyrHpbJCWwx6SJsNBs43OJkKYEqZgqqMZkpEBMYEPUhR2BATGBA1IcEBsSEDYj6kMCAmLABYQMCA2LCBoQNpNoSCxXN0tUHgQFjRe3Brb9lwQFhAyeIAcWKZpl9ZwADAS9TMtwyA1DcENST8YEzqhS8iQhZpT0N8yfb4/MUzTL76qdhdgQ2oGcG3G0wUNIQJL1CZ8UG3kCELG3ZZsD9WoTfZWHAyXm193U0DHRq1H1UBQzA6mUoKjAOsjAQwrb28Al3peYHvBLqL9OEZ5UbeAMRsiphYDRfOeWKZtl99dMwq2SmIDB44BoYaAEM8OqlITYZp2Cgf31IvCB2OmygUzsRMn6E+Gb5G9qLYfZpQVNMgCn6LLij2m5mnKPZXF/782BQGo8UK5oV7SO8mX/9dPowQAoiIDvkuyk2gIucjpNFjFMJgBIYaP8tMHD6bKB+ImTwCKBbEitsUK9ALPAh6ZFY0ogBCBWNABb0feYL51BFs0xuIHkgwsEGwUAYbrAB8v+9YcCTWkED2ED9RMjwEdQ2wBX1ig8Y05nJWQwDOBW90BdQ70fjT1v0BYoVzXL21SsqqGRh84BCAzfDBrpBaMNAKiigsiDJCTx+u0g+SG6gEZWC+omQxcwhtDNrQZIEBuishKvPRv4dwcD9LUQQHMYUdg0UKJo5BQXD2miYVcG+IRzAFOFw6OKEoe9CvnAcYlQAoiQaBlLaAlQOaNkwQB+kUtAMNlA7ETLDBggGWMbEZgP3CQzEN8vnj4YNbPnlLlM0y+5rJBs4FDykb6DZuYH6iZDFFEoQDMADJr7v8FkWyFzdEpzN4WILK8VQmBvIVTTL7NvIDfy6O1sYkC7ChrOBchGyzhFEyDqFImQEA6R/xhE+POBMOzZXChBWuCagQYYfDCOQmXOIollmX7ZSEA1m5wsDYs1mA7tZZ6fNu4mQbbN9BUSpOJn97d9f0Sy9byMmiM+ZDYg1nA1U2bD7MhGyw2CA05EZpz9E0czeZ/VV3OqXN0cBgQGxY1UKKrVKRMj2ggEVMRxZ9KzZMwViwgbETssEBsTeNDcgJjAgdqIw0O/1LvofPnxotVrvwdoKEL5cHt/6ZJdilX0XlXUR4trEuRZAgyEvW5qyh69fn8WfThwGWgQDgAKvAwMtNIGBCr+LythArp+Xw4D77HWfV+JQzckNdL5gme+o/zl9zT36zvHvVav/EhGz3O/ihdeuFAZQW6D7pLUFYA2zKbYU+643fMLZQ3umYLXqtp+FDkilYD9T97xU/9/vn1nonitiVuV3UR0M0BKF4bAN65jSJIFmA9MQh4zsmYLnB+95JTAglYL9RMjgntF/zggG4u9/OZuDypH/SX0Xy/GDQoJ6wQBpC8B8ofqYhgG1mxY6TWBg9ey6AgNSKXD2Uh9S94y/Przv10mE7LAmhR3vkYUBx4KB99FN7dgAjxFqGIChw7BbAgPBjdt9EBgQNrAvDCzvVyoerpMI2XFhABx+Q8QkGn5ESJz/j3IDNQoKQgsG2OtxI8OAnRv467ndlhRhs3MDRxAh60NIoH4B6yBCBp9hfon+yvGf33jrGAeQtDoBCKPoJzPzlfpwugc/ggKi1v2gVNIk3YhMzOjPPw/ABqIXA2IV6kPql388bGttAYsNAB1Qr5Ai1DCQ0htYScGw2WygcwwRsv77zyuIh2sgQkYPz3/H6F7d7/42URLhIWL9ZAwD9KUYhSN6hOXvX3elQ1M5Imbw/atvoy4wUFQodKcyMHzOuYFjiJD1l99XzAbeWISMRpz478BnVycaP2cY0Nc3Y9Z8gQRq4Ej8UsrihBwRM4ABFRXUJyjYNCgV+q74yznnBo4hQtb/849mA9WLkHX2FCFjlKO/g2EAaD4CRGxHPCYomC/SIQ89wjYZooKCYWVVE2kmFjsWGziCCJnNBpy3FSGLLbIDIQvDgENyJfkwEGVggB6hHAbyRcxOgA2ICRs4hgiZnRtwnLcUITOpD/o7bBigQOHOhgGdqeAvhe/Bj2BgwPz1ebmBdFSgvv8W5QYGtwIDYjWtFJSKkDkHiZBxrTxfhMx5HREy0iKEm1GlYOEYGIhNbBNRpcC0Q63gEPpS+B70CAYGRp/zVVVyRMySSkE8WAgMiNWTDeRYJ/ftDsYiZNw3sPXyL5cdcQpFyFI36xz095T0ExSzgYyIWdI3YCiGwIBY3XIDVRqLkHEX4VE6eja7iu5KYOA4vcP5zQO5ImbMjBSvePGSqAIDYq/HBl7iH9hG9LLseM1EyF46ZlW3mYLdzJu6Ydjthr7vBzscHobSeFBbGMjRG2i/kt4A3FX0BvC7gO///+xdC2/ayhJOFhOThbaCjdk0oHtrBbVUYCyC0kpB96D+/z91dx5rr8E82tMkPGbUU4K9Nrgn8+23szPf3B+P3sCBMPBCMKBilR6QUmCNwMCxw4D7PfwIOBB9fGX1oehd1YciUR86wL1tD1KFIGPIxKqXpsvEvYP84moZgYMBSC50MBC9wPDuSxSrl5euc3b3pguHkSdYwy/qRboXHfGioLG2U/DKuhs3myG6t5L8uDpGHZK/9W/x92oKTNmzVHXbPWsMNDJdlxjws7yDgBcNLu4GQPNTYwAWcP5HgLAvkRsgvnYCMFCJDYidrv2lxubKYoVRVzV6uucmfRAfwkrjGrKPM7+b8btd6+uPLSQeIxg4vgDFSQIDJ8MGip0CAQKBARtbi2yAYWB7EJD6nvOAQobAAYHAwKmygQ/CBgQGPAxAb3PPBnx0T9cuCsD/ydFLNRLwfwO7CQIDpxgbeMy2s4G7z+l/xNMuBAZUN+kVbAAlSdW22AC6Pa4NCAZ02oVAIbxQDFFg4MRiA5Nke2nMzRoMjAQUzhEGftda/3qA2NGwgeEKYWCYHR4bYBgYrcT7LhkGxM4HBh6Ta4CBu+fvNzDrT6cpVs1Mp44djNLJdOp8fYh/O7d3P2RX7tgUT9+NhRUIDIidPgw0xqnGRcFwBSHCx4xCAWOa50fO2SdYWTxEGHBggG+LRcHjjpWEmMCA2EnAwGS6otjA3fgbwgCzffbu0fN31gUhGEhJ8yOIDQyfv4sHCgyInTQMDBEGblu3zrEBBmAxAAX+7OaBu5cwkFWOTyU+IDAgdtIw8LFYFDxmPm9g4nBgtAsGvsmiQGBA7BxDhJPki4eBu8/f3H/ZNhgYguNPvCChhAgFBsTOAAY+4obhcIUdjWGjYJpd0Y4B7hSwoh9sDayuRrRBgGsBPC0LgpOHgXyw50KoLSpse+PzNWvPO79RVGigAlFV5QsMVCpg4YLhAYfaji9p9usj6P483zdGJWr/P0U+77fnfX0aMIBZhG52r9YU3OxKFxA7Ixjo9Du7f+sbfwIDUee3vo738sBLOf2QS5TfDgZ0p73/E1S63PtP8QlxcJCfChtotWKqMNwvBCgwcHYw0Hc44AmB1xvo9RLMCE4SRe2NDbY5NrHFckMoF4CygeUSjtUJEsTRAHyEBsClvUj3et0lyBh04d5rJQpFo0SDpAAGsP/zmfX+qTgjF1/SncZvDJ9k+Uv6p6AWbDQOhBTwAfFSHhA356HjNzfmb7i0eAp6dGWX0MitKswQDyoEiAAgz0+HDdzeHlZhKDBwjmzAAcHA/8LDL3XE0gE9hfVBtCgABYGeZ8LOW+EHi25RK0igOzDODeDKJGPcvW2vbbFswV1RhQFOOm7BjR0LUC9QlNDtKlgndOuVixp4mL8kfGMoiLIBG6CnYBjwXZqRDSjEAH7MOL6vwEA+2M4goMLCUH9XZehTSmGGNRjQffwf0h6cDhtotURv4JLZQL9TsumiiTH+mluGAXQj9n4MFyiqHHL/1QkS5DSl8kwM0zN4jVXOfZKEyMM2zo6ej2pG0RYaEDonf0mEIrgW78xfkq7kvsy9YNWBPZnLXs3V9byz9jrtwIH4FPzoykZWUZvXohRzPcAwp+hIe948NzYgdpaxgX6xKICpOt0PA/FSLelktOEAPFcTGyAXdJOvKWDA7vguwAb8gAbCQOswGGgQDMQEBP8CBmrWBAwE9BT86O5SY9wDhcIMa9dwUOCk2ICoD10yG/gUxtaMFxICzwfFUaL1rCCgSYJULU3MkqS6VpCAYgOFC7oVAcMA36BOvqCt8VNIxqyWDej+IIjS6fJLKg8DHAdQAQy4dUGq/ceixBp6tJvV+daV2AC7bV6dw4ED4FPwo4NEk3UPFAozVBcFPkZ6SrGBlrCBi4WBQbBhCCTXOZQPy3VRaADYsOE4WQzqAzZmR7PU67hOkCCEgaiXpEsPAxCegxvVyBfoFHcIed+wjg3oTuBohuJ8+CUZBkwSfMnyKZY9Pw4eAyICdCnfuhIbGLR5v7M8ZvH56Cn40eFSBy5VYYYKDDT55zwXNiB2WulDB2cFcNhQ/a0Nw8Mx65W9wq8Jmv3mIWkUO75pXn09idiAaBEKDBwOA4qD9ztg4DfThw6z+/kro0CjzyRgsC2up7oHdVzI+envTyB9qD3OGsNUr7OBmv7kYpcBA2IXZ532MLlfh4EbgQGBAbGLggFHBvRuNnBz1/0i/iUwIHa+MPArmTUcGwBZsdZtIT4GtUXfUFMA/xJVEYEBsXOGgfHq3rGB6SqaPM+cy38A4TFwfWADIDtCxcSjqSwRBAbEzhYGnjNQH3KLgo/jbJR8+QAK5V5X5M5BwJCqiCfTTFxMYGBb4Fz9/kW2J31Nj8Va/U7znmMDj5lz/woMXD1md93vDAMiMHQ5MKBTLLozmIZjt3YvLDqWbWyf+RqeWv+nU3bznsbn9tQjhP768LQTOmZ8ejELjj08ZOEdHhZ4LDgoFsf/WzTX2MAogIFROmFxUlkUXBIMsLgAOuwOj95+akfqgU/orbUlJynv8fMtdl0DA3GcVTw+epq5P7F+kjZKgfXbng049598hthAhvGAR3D8u3EX3X8kIcKLgoGgYCcuKmmpDsf6zOFU+4r+LiYb+5J/S1oFVAqA6bqcwgsDUs3CBQZP8ACzpJJ/jx748XmYcpM9IBFAGIC5fOZfoiec3z1KPD181XDCvWRPD09PX7WHgdkDYYN2GLBY7AOUi4SBxhBkxa5pp2B1g+Ji2SMKkuNSQDYMLwwGuDsp+jL4MMiFUHF+gqX7hr0cX0xkOcm+HECJ+lyOp1IVFwPolG5TUj4NMKBrooob0seHMOCd1k/3bi6HKR3OLEI24Kj+ImM2kH2dPWQwiGDgGmHgmlYD2cNCXL+aN4DKxFhTcOv+rNUUUIBQkosvCwaY7LMvW+/xUFfbi9xJT/m5KseXH8NkTgNoPsfj0Bq5uBtU9vl4grthMcCWQia1KwrP8gs24Gb5Bfr1LAwXwOmsgIFs9qRLGCgXBVmcPUULYQMbMFBWGH6o1hRMZDFwiTCgLSn/qXKBoKCm3tSV7ZeSBOzyhcoPH2dQMSRc5COEXO3vB4RVSptlOx4GgA2AH9PKfgMIrqswcF0HA3G2gKNMJsSqMFBXYTiZSmDwImGgVBoomAHoeCXeYf3OgC0m9qUmJQIeoMtlQKord4hLHTC95AHcSH2NhYSLgow9fYYwMHOEX5fBP8SEGZD9gg1km2zAxwaKEKHAwBY2IBWGAgObEUJWGIF6faW4Pt9w6I9VSFNWIiBxEoVRw1Lz04sB4B28VIE7F4iCetGgIDRQDREuIESIsb8FLAoWTxr2/hwYZLz3dx3CwAxDhAQDMAAQ4LoMK/oXsYPYgNiFwsCebbvXS0Oy+3IOxN4kNiBsQGDA5+9QMs/bGSUrceZSxb4+vIaJ8wsbEBgQE5PYgMCAmJiwAYEBMTFhAwIDYmLCBgQGxMRkp0Bg4HgMOgMcu5q/sAGx84aBfNCsbhkWegPQw3dDVqSa9r9VojyiysF6BYF/fv4ob4JC/rovXEZiA2LvBwOdfieYisN0Pu7xVR1eSfvfpSDA5Qk1qUjqR3AL5gFCB4QNiL0jDEA/45IQhNnEWFvYi6zBKR3TfyE7uMgFjkhBANOI3aklKQlYViziIkS8YaXjd/zjn/Jn3+Pr2Dt+ChsQO3M2AC2Nqyyf5QS4ZghLgHxD35InGHZ1LBOC3oQG24aqSukwja/AgA5WBEVvr2ZHyn+FDYi9Kxvod4olfVDpRy08ifh7gQB89W/Y1alg2GCZENKFoD5xQ0FA//j582exKihaHQobkJ0CsfeNDfSLRUGoN8COTOqEXlkAXwuZAcuFxIpogruiaEDM/r+pINAK1wS6o8vtAjFhA2LvxwY+ldE7W3IC78jWBwM5CFC+8dyht6RrQJDAu73XJMSrw0VBFK4JGh3fQFh0QiU2IPZ+MDAINwzXI4TlGp8VBCAsWMgJsIKA8tICcIHlTcYwNFCBAR3uEzAL0B0hA8IGxI4lfeiP9AYoamhrDtYpCIRrgjhuI0AMZLtQ2IDYscDAH+gNOHoQCBeWB7uqVkHA/PxRDRZIDqGwAbEjYwNislMgbEBgQEzYgICAwICYxAaEDQgMiAkbEBMYEJPYgHiTwIDYRcFAe5xhY/NNNnBz93kq3csuAwa26w1AllBiDrgFbTCyxEBlA7I/nx9SLNCczztRnM/nc/dd2oddI/aXYGCY3DMM3LZuH7OQDdxc3QkMXAYM7NYbONAo7YgrEkoUODQ58N5nGVI2kdQZvSUMODKgCzZAMHBV8gGAgRtpbH72MLBbbwAxISn0Bpy/p8gTupgfZDhzOCw/CFqPRQwDQAra7t18nsd60ME5fwBv8EwelBnnCAACA28IA7+SWcOxgeF0mrXcX85WV8P8c/JrCj3NmQ0MhRScPRvYpjegU/Rxa+PYSwyA+ABIjFDvwfU6IsSQsAPhpzm8YTQY5PCT7ucw5+f4xucPMgwM5nTtJ4GBt4OB8eresYHpKholXzwbGD7Pxukk+VLAwNVIehufPxuo1xuA4IBlF2eJAagtdFM/KBG4wzq1IYeoa0HYdut8cnKUFshzKC3WnYajBPP/tvF0HLCBNuKAsIE3hIHn7L6BsYHJ86yAgdXd+FsFBq4m00xc7LxjA/V6A8wBuNCYJAZIl0wX/q4SU3KIDYkRWhA0N2Cg2W94uRECgv+zdzU8yTNZFCmVwpRnol2LodslJm/MxgQJkGCyZv3/P2vvx8x0Cij6rqLSc6JiSz9AuWfOvTP33kADWpoUNHAyZGWe3mps4BgN3CA+cN5q4HC9AeEDX0HAlRjQ+kPRsC8nhLoDgx2ngAf6Mh2X3img35gGlpULAnglkLZDhHAKTof/btL3qAE4BWdOA6/WGyhuQgWBECHUumRSXGDKk4s6RdiqTBDRQFKuODbI84H0oOFA/km2zvFCOrByB2i6sTwDNXBSlKalBv55969DNPAXQoRdWj50pN7AIe+/CSVM35Od7OsNtdcNtAuSggZOTAONGvjHv2WmwNHAXzxxQAyACcNO0cCxegMHvX9dauRKDBy/xSEauPU6QKMFWD50ynUDRAN/juQUYHFxt9QA0Eka2M0pAEADQBdpABmGoAEAagD1BkADANQA1ABoAIAaQL0B0MCJwEkEBycLAKgB4LQ00K4xcGAO8Kp/oO3YDra7tcbbtyjHQ7Pcv3HzE0BsAPhOGmjXGDhAA3fFURp42b717DhfpfuNCd26oARyAGoA+HYaaNUY6EvRAF4fXPjOhMXzlJOJdV9xfXV9Tfs5RbjBYNssFuKVwfmA1/2sKulAVC3Heb3kZCLZl1Z5WfNyYmf+oY8xADUAfKMaaGoMNAuE+bepeANFUfQTn2Bc3PWvDD3VpoF+1JFUqwZYcgPoN1L8ZOZpbiuyeiP7zMrm1dI0zgD6F0MNAD9CDYQaA1NZOcx5QiwKppxlXBTjKbGB7iNKiFKLneZ/IgSvwHB6ENs2VxJJ8wFpf0MkYPKB7jN5knNqsbd+qAHMFAA/IjZQRlFCJoKppBAPB9Pxs1QWei6uB7qvKJI9Gmj5BEwBq5Rtm/uTj/OkIglgBvlD5fYtDbPCOFj/TiYRADUAfI8asK2QYDGcFsO+lBd8LmS7PyUakH1eDbScgvG2HeWryOzTcUk0MJCoQ01j/8rtIyGwXJLpBxpAA2PEBoDvp4G4xoCrGtC/urmWQmN3faGBwbWECK8bNdCigX40T6ChQa4vbnmYr9zSALNKdV+SjyvDkwSu8qCBGIAaAH708iFfhvBt7PgEMd5Q/KlUJElLTBdCDQA/mAb6N9fvGam3T68tGjCrt4Z6rCGEGgB+gxoAMFMANQAaAKAGANAAgNgArAk0AEANAKABAGoAAA18MW5XyCmAGgC+mwba9QbGd9J1RAqND65v9guNt+uSv9qOgM7l67gq5+1pxJXmHSnSPRrALCJmCoBT00C73oCrLCDmLY2Ld624VXqA25i9BtcCcbfdSVqmw6V0MX4NqEAANQCcmgZa9QZaHcu0V+lgWtyFjmVcdUCSD3mD1QKpBmYLbmn4XIgAmHIvs2FYgigXrJp1RGz/gzxd1iUvOnYNy4y2KBGhwLvQowSxAeDEaqCpN+BVvg75ZME03A+u78ZECyINilgnFM7UpbPpVBoaTwt+3rU9LJoLRjRQaR7yshxzJrLu4DXHy8qvLIZTADUAfIcaCPUGfD9iGcm1V6kKf3lCexg3G87Up9LWmN2HohC50G+utNfizNPA0mcX0Y6lCgDnKMApgBoAviE20NQbcA59ERmyVh4Sc/Yjvd9w2oGMX2UCnRGykZz971Ux9E7B0tcdYhpYhqegBqAGgO9RA029AbViJQBvyFMfDHRBgGbDa4frZz2HSxZ6s3e/6NmRU8DKX0OE4zL1ToF6A8Y5BSVWPWCmADgtDcT1BvYihI2PL0FBmQi86fsNnlecaqRAypjyCVM3yRiHBmIaYA+AQwEaG3RegttaylwiPyBECDUAfNvyoef+oUm+I9Co4fTAzqjG6WtALULEBoCfRQNutU+hUb53geRBPxINYSdLArcW6XUk5WqFImRQA8DPUgMAaABqADQAgAagBkADAGgAMwUdoIGrq+EVPvIA1ECHaeCKWGCoXwCA2EBn1YByAH/377BgD4Aa6DANDEEDANRAN2ngqgHTwH/QMwiAGui4GgAAzBR0mQbABADUQNcnDMECAGIDHaaBKz9NAABQA10NEYpHAK8AgBroeGzgagi3AIAa6LxTEB4AADMFXVQDAAA1ABoAAMQGOkEDFwDwUUANnBsN4E8AfBhQA6ABADQANQAaAEADmCkADQCgAagB0AAAGkBsADQAgAagBkADAGgAaqA7NDDZDt4+oJ7P5+YDd8zKMsHf/QuwmM0e3zxgo09fbCbNf3c9ux+2rvHI15nNNlADoIEIo+3obavOk54ps3ffcJQbjBtfhM2HaaDXG64jGrhYr/WYxeLdagAzBedNAy9PT0QB/e3EbTy9ECfQvl6vTxt9d9RtnvUS+jbzOZFBbct5PuINUgijfD63PVPX82j8z/IMf/VPxuNMx3S2cxrfZ+uJPGz0mYtAA4v72YKfmM0Ww/X6fjFbeBoY3i9EGzwqVbS4AWqgyzTwQvZP/9yXF7+x7fPXrkAwNZk7Gzu5B2aUlxnZuZo676bfDFFB3XgNJh/hr/65uPBG69UAjeWPouonm4tYDdwP+VBRA2T3mzUfFNPAYuMucUQMIDbQGRrwti6WzwGCEX2/PA1ka9vISjvnIZ8H/nkEAvlRAAAIb0lEQVQtHoIQANs6M8OoSmw+op9eO5Q1/uafHhRYxKp/w4N97+J+PZGNx5ZTMAw0sB5uHhsaCHQilxiuL95HA1AD504DYzX1kUQIR947IAbggX7AroFCB3on9ZPKDfUJmbu1soMOiByBhhGAL6GBR3IPZMc+ERyjAYkNsiux2PSgBkADSgMjJwomLxP6SZY/6YWJg4HXA86snQwwYawn+7fiLvABgR1AA18SGriPnILH9UQVvjdw5oTh/SaiAd6/QwPuFL3EUTEANdCh2IBECCfbJ3YEtk/bl62LE/KuJz+LmLiB3ohvwAKgJx5CmbgIoYQPG08gYgTg0+SAhAjZG7i/4CnAzUJG9gVZtwYPWzTABy4cDfABHFFs0cBRMYCZgu7QAP1fY4q/dN97Rx3eujx8QMwIwK8F1EBnaOBrgMVDX6EFvgALxAZAA18IfFqgBoDO0wBwPjQANQAaAKAGoAZAA/8feMEBAoa/Xw1gpgA08A6McrL1h724YG17mmfEMHMsMYYaAM6YBpIyH+3nE+kKg14qciBBuhFiA8D50EBWcmqBLCaqeWUhfZuqSnjRkCQfmIcyr8pmXaE+wjeAGgDOiAY0w4DrD1jLip/XFNvakJ1bkv21saUpLXkItXW0ITrAbwFQA8AZ0MBSFgfVRrx+KxnGTAJWUgtIGtg6qf7kWcgsUJlg8H+AGgDOKDbAFQckm0hSCZKH3qjOkqoyPOybfPSQWEumH2IFEiJAnsFvVgOYKQANHOCBKqGvrCy5KNHDqJfVI94gw0/KnISAeAieBgaSmAgagBoAzogGtAYJPZSWTFuyj6UsEccFaB95BFmVsAJw5Yg0KGARGkBsADgrNaC4fMO8+blU1glYnSGoERuAGgDOkAbYuOdvDfLxGkIsHoIaAM6UBgCoAQA0AHRCDWCmADQAQA1ADYAGTgVrZUmCbjx8XQGj+miYwr4W0EzKD4c6/Vv6baupERsADXwiDnz8Lw/OL+icAi9I1oKnbDx2XpPpzT8nvuhvW++/olass55rCyYtpiZzHCE/4iPl1ehdmPCWQqYl1ADQQRo4ZPKHpg8juiCL0bOk/ZEWQf+EV/KWIUbLm2pLL+XSH65l2f/mUN46La1/JQ1ADYAG3mHlMm5rd0O7zPmhSUGkDWd7t2XU5FAXFvKpZOau1Hmcp5zlt5qQIGTA64/oO5ErJNWSWye6W8gVRpUt53X8griVWmi0yKqi5qO5LTM9WNmT5datgpKHSJ/QC27as0inJq7K/sC3oLtqBYVInrj3rO/iYTl/KGUdlb6gFt0p09jfMnEKNQAaeD8LyKda0w05gYhzDeIURGfekl5k9w2CWyJqnwNbt7il0dF8RbqWu4LRTgl1UNvaVLEZzLmPWu4bLWrXxZ5rqiQHZUbG94ysVXMilacig03nzpnPmwTpWm5hMnmVLX2j71l7Of7Jc1OaOjRxavdtcZmWv40GMFMAGjgG19C00hXFtWYSWB73/T41UB6Jm8+/mJacKklIrkdqy4vnkb92Hrr2UdYrsB3Sp1Fu4a6QlaZR35rlmKmUd10XObgwD0uZLuUVsZPvcyIzuUtDQ4aPTtwOsXm5Bb9+eZUmTpfU9yzvIs/YmTG1vx/fxR70O6AGgHOiAf1oiyXVJvQwc2OxWI2MnzvtzGqfc0j7hQLszhG0xceI3eot/POOLS69BBi5eic24iUy2Oh1NR66O0g2lXnc0Tut2Gtj63DHECHks8OrCA6Oe8/6LrJa0ikCJ7UN/5elVSA2ABp4Nw3oUJqLbs9CDzPOP9R9IuRNCM7VoreZHRLxBFSZ09DZpoGk+lOayGBDeK85jO0/XIGvGBQCj+N6kuu6mDod4iqfkH5YyuQkv8hMR/04lsfiPpi83tfLFTreBnKQod69Z3kXZP+ZpFe6+7UnRDQgYn5NJxeoAdDA34oQ8sdfIgQSdXPROSPRskRDeo4GQnSOTiDNX7HBRSaTeVEtI7EzXr2CG7VDliNfwWsJq+VQ5uWDDQO/HudmAI06JoY22Lr5Wnp0fHdxJKIKCVbCiu4W9GSt1de84nfvmV5yTSLCSnplmHFsOTr6Pn4fDUANgAaO4vLojv+1d3ctjQNhAIVjhUHxooSCvfROr4LgZf//DzM1iWTSaUsQlc77HFwWd12UwJ6ceScfw5+mayuL+SNLx3N+VgjXT0XTVxz/2eUfK+Xrj8V3Gv/zzgMhlb9fWvzt4nWQ2UpjHIE+3cwdVmqABv6O6cxZWjpvX1ZvtY/n/3VfXbxR8qdvYpwuHmpmUjnuT9zibMBOAQ38OulCRvz/zxUVNUADCI/ZAA2ABtQADYAG1AANnCeffUENIGQNeBFZsBqwU0ADp3jMsBpAdA0s7hCA2QAC1kB24xzUAAJqwIvI1ACiayB5EZkaQPgaMCGMVgN2CmhgSXbjHNQA4mnAxUNmA1ADUAOgAagB0MBE2zato6sGEFgDbW+BZvhA5TVgp4AGmuM7h55nuwO7w3D50OiA/tfjYecwqwHUXgPzawUWGmhowGwAETSQXSuw2Q9rgon+s/3GYVYDqFwDxdsIDAbUAEItCt4LT+s2IlQDiKSB7bZwIvjaMGSBADVgp4AGmjMPGmnHbQKoAUTQQOFuouHaodaqwGwAQTRQfgbpIAIaUAMIoIH77OKhfFHw/RvUAGrWgLOAGlADFgUIXgN2CmrQwAOwFjWgBqAGzAZoADSgBmgANKAGaAA0oAZoADRgp4AGQANqoFINdB+OCMwGYmsgvb3yANRA8BpIHQ9ADUSfDfQ90DkoUAOhNdDIAayrATsF9WmABaAGomvgjgVgNhBdA53BANSA2QCgBmgAUAM0AKypATsFNAA1oAZoAGYDaoAGoAbUAA3AbEAN3DCfn/Qdg7Fvt6kAAAAASUVORK5CYII=" alt="非函数原型和类成员"></p>
<blockquote>
<p>类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过 this 引用的数据</p>
</blockquote>
<p><strong>5、迭代器与生成器方法</strong><br>类定义语法支持在原型和类本身上定义生成器方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在原型上定义生成器方法</span></span><br><span class="line">    *<span class="function"><span class="title">createNicknameIterator</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;J-Dog&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 在类上定义生成器方法</span></span><br><span class="line">    <span class="keyword">static</span> *<span class="function"><span class="title">createJobIterator</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Butcher&#x27;</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Baker&#x27;</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;Candlestick maker&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jobIter = Person.createJobIterator(); </span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value); <span class="comment">// Butcher </span></span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value); <span class="comment">// Baker </span></span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value); <span class="comment">// Candlestick maker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> nicknameIter = p.createNicknameIterator(); </span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value); <span class="comment">// Jack </span></span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value); <span class="comment">// Jake </span></span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value); <span class="comment">// J-Dog </span></span><br></pre></td></tr></table></figure>

<p>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">yield</span> *<span class="built_in">this</span>.nicknames.entries(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(nickname); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(nickname); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以只返回迭代器实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.nicknames.entries(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(nickname); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack </span></span><br><span class="line"><span class="comment">// Jake </span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>补充</strong><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield">yield</a>：用来暂停和恢复一个生成器函数（function* 或 遗留的生成器函数）</p>
</blockquote>
<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>ES6 原生支持了类继承机制。虽然类继承机制使用的是新语法，但背后依旧使用的是原型链</p>
<p><strong>1、继承基础</strong><br>ES6 类支持单继承。使用 <code>extends</code> 关键字，就可以继承任何拥有 [[Construct]] 和原型的对象。这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bus) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Vehicle) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承普通构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> Engineer()</span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Engineer) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>派生类都会通过原型链访问到类和原型上定义的方法。this 的值会反应调用相应方法的实例或者类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">identifyPrototype</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(id, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">identifyClass</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(id, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vehicle()</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus()</span><br><span class="line"></span><br><span class="line">b.identifyPrototype(<span class="string">&#x27;bus&#x27;</span>) <span class="comment">// &#x27;bus&#x27;, Bus&#123;&#125;</span></span><br><span class="line">v.identifyPrototype(<span class="string">&#x27;vehicle&#x27;</span>) <span class="comment">// &#x27;vehicle&#x27; Vehicle&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">Bus.identifyClass(<span class="string">&#x27;bus&#x27;</span>) <span class="comment">// &#x27;bus&#x27;, class Bus&#123;&#125;</span></span><br><span class="line">Vehicle.identifyClass(<span class="string">&#x27;vehicle&#x27;</span>) <span class="comment">// &#x27;vehicle&#x27;, class Vehicle&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>extends 关键字也可以在类表达式中使用，因此 <code>let Bar = class extends Foo&#123;&#125;</code> 是有效的语法</p>
</blockquote>
<p><strong>2、构造函数、HomeObject 和 super()</strong></p>
<blockquote>
<p>继承自其他类的类被称作派生类</p>
</blockquote>
<p>派生类的方法可以通过 super 关键字引用他们的原型。这个关键字只能在派生类中使用，而且仅限于构造函数、实例方法和静态方法内部。在类构造函数中使用 super 可以调用父类构造函数</p>
<blockquote>
<p>ES6 给类构造函数和静态方法添加了内部特性 [[HomeObject]]，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在 JavaScript 引擎内部访问。super 始终会定义为 [[HomeObject]]的原型</p>
</blockquote>
<p>在使用 super 时要注意的几个问题：</p>
<ul>
<li>super 只能在派生类构造函数和静态方法中使用</li>
<li>不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法</li>
<li>调用 super() 会调用父类构造函数，并将返回的<em>实例</em>赋值给 this</li>
<li>super() 的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入</li>
<li>如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数</li>
<li>在类构造函数中，不能在调用 super() 之前引用 this，否则会报错</li>
<li>如果在派生类中显示定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象，否则会报错</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">age</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">myAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.age()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> P(<span class="string">&#x27;Ject&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实例通过 prototype 也是可以直接访问到类上的静态属性的，用 super 的原因，个人理解为 当实例上的属性遮蔽了类上的属性，而又想使用类上的属性，可以使用 super 处理</p>
</blockquote>
<p><strong>3、抽象基类</strong></p>
<blockquote>
<p>可供其他类继承，但本身不会被实例化</p>
</blockquote>
<p>可通过 <code>new.target</code> 实现。<code>new.target</code> 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle不能直接被实例化&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bus <span class="comment">// class Bus &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> Vehicle <span class="comment">// Uncaught Error: Vehicle不能直接被实例化</span></span><br></pre></td></tr></table></figure>

<p>通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle不能直接被实例化&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.foo) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;派生类必须定义 foo 方法&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Van</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bus <span class="comment">// success</span></span><br><span class="line"><span class="keyword">new</span> Van <span class="comment">// Error: 派生类必须定义 foo 方法</span></span><br></pre></td></tr></table></figure>

<p><strong>4、继承内置类型</strong><br>利用 ES6 的继承机制，可以方便的扩展内置类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">shuffle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 洗牌算法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="built_in">this</span>.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(i+<span class="number">1</span>))</span><br><span class="line">            [<span class="built_in">this</span>[i], <span class="built_in">this</span>[j]] = [<span class="built_in">this</span>[j], <span class="built_in">this</span>[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> SuperArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.shuffle()) <span class="comment">// [3,1,2,4,5]</span></span><br></pre></td></tr></table></figure>

<p>有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原型式里的类型是一样的。如果想覆盖这个默认行为，则可以覆盖 Symbol.species 访问器，这个访问器决定在创建返回的实例时使用的类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))  <span class="comment">// 这里会默认使用 SuperArray 类返回新数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// [1, 2, 3, 4, 5] </span></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 3, 5] </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span> <span class="comment">// 返回新数组的类修改为 Array</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>)) </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// [1, 2, 3, 4, 5] </span></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 3, 5] </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>5、类混入</strong></p>
<blockquote>
<p>把不同类的行为集中到一个类</p>
</blockquote>
<p>一个实现方法是定义一组 “可嵌套” 的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> FooMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> BarMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> BazMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">BaseClass, ...Mixins</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Mixins.reduce(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> current(accumulator), BaseClass)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Vehicle</span>, <span class="title">FooMixin</span>, <span class="title">BarMixin</span>, <span class="title">BazMixin</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus()</span><br><span class="line">b.foo(); <span class="comment">// foo</span></span><br><span class="line">b.bar(); <span class="comment">// bar</span></span><br><span class="line">b.baz(); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多 JavaScript 框架（特别是 React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）”</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javascript/">javascript</a><a class="post-meta__tags" href="/tags/%E9%AB%98%E7%A8%8B4%E7%AC%94%E8%AE%B0/">高程4笔记</a></div><div class="post_share"><div class="social-share" data-image="/images/class.webp" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/javascript/gc4-7/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic3.zhimg.com%2Fv2-27e40447e4827ca0ac9424b8f37f6493_1200x500.jpg&amp;refer=http%3A%2F%2Fpic3.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1642237778&amp;t=24e8f9ce6970bfdc2ddbf8bcc80bd6a1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第七章 迭代器与生成器</div></div></a></div><div class="next-post pull-right"><a href="/javascript/gc4-6/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://smnarnold.com/assets/page-previews/js.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第六章 集合引用类型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/javascript/gc4-10/" title="第十章 函数"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/function_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-30</div><div class="title">第十章 函数</div></div></a></div><div><a href="/javascript/gc4-11/" title="第十一章 Promise 与异步函数"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/top_default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-17</div><div class="title">第十一章 Promise 与异步函数</div></div></a></div><div><a href="/javascript/gc4-20/" title="第二十章 JavaScript API"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/javascriptApi_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-04</div><div class="title">第二十章 JavaScript API</div></div></a></div><div><a href="/javascript/gc4-4/" title="第四章 变量、作用域与内存"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%253A%252F%252Fdingyue.ws.126.net%252F2021%252F1015%252F0f63ea96j00r10a7f000hc000hs00a0g.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&refer=http%3A%2F%2Fnimg.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642295342&t=1541235e44283cd50dc0888b18d1a3dc" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-15</div><div class="title">第四章 变量、作用域与内存</div></div></a></div><div><a href="/javascript/gc4-6/" title="第六章 集合引用类型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://smnarnold.com/assets/page-previews/js.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-15</div><div class="title">第六章 集合引用类型</div></div></a></div><div><a href="/javascript/gc4-7/" title="第七章 迭代器与生成器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic3.zhimg.com%2Fv2-27e40447e4827ca0ac9424b8f37f6493_1200x500.jpg&refer=http%3A%2F%2Fpic3.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642237778&t=24e8f9ce6970bfdc2ddbf8bcc80bd6a1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-16</div><div class="title">第七章 迭代器与生成器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">郭伟杰</div><div class="author-info__description">尽吾志也而不能至者，可以无悔矣</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/guo-weijie"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/guo-weijie" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:weijie.g@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">少壮不努力，老大徒伤悲 <br /> 君何必言利，亦有仁义焉 <br /> 一切古代史都是当代史 <br /> 每天进步一点点</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">属性的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">定义多个属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">读取属性的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6"><span class="toc-number">1.4.</span> <span class="toc-text">对象合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A0%87%E8%AF%86%E5%8F%8A%E7%9B%B8%E7%AD%89%E5%88%A4%E5%AE%9A"><span class="toc-number">1.5.</span> <span class="toc-text">对象标识及相等判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">增强的对象语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">对象解构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3"><span class="toc-number">2.4.</span> <span class="toc-text">对象迭代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">3.1.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">盗用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">3.3.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">3.6.</span> <span class="toc-text">寄生式组合继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">类定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">类构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">4.3.</span> <span class="toc-text">实例、原型和类成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-number">4.4.</span> <span class="toc-text">继承</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/others/nodejs/" title="电脑安装多版本nodejs"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/node_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="电脑安装多版本nodejs"/></a><div class="content"><a class="title" href="/others/nodejs/" title="电脑安装多版本nodejs">电脑安装多版本nodejs</a><time datetime="2023-07-23T00:54:59.741Z" title="更新于 2023-07-23 08:54:59">2023-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/javascript/array/" title="Array 原型方法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/top_default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Array 原型方法"/></a><div class="content"><a class="title" href="/javascript/array/" title="Array 原型方法">Array 原型方法</a><time datetime="2023-07-23T00:21:13.023Z" title="更新于 2023-07-23 08:21:13">2023-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/others/nodejsNote/" title="nodejs 学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/node_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nodejs 学习笔记"/></a><div class="content"><a class="title" href="/others/nodejsNote/" title="nodejs 学习笔记">nodejs 学习笔记</a><time datetime="2023-07-18T02:55:14.786Z" title="更新于 2023-07-18 10:55:14">2023-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/javascript/object/" title="Object 原型方法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/object_static_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Object 原型方法"/></a><div class="content"><a class="title" href="/javascript/object/" title="Object 原型方法">Object 原型方法</a><time datetime="2023-07-18T02:04:11.857Z" title="更新于 2023-07-18 10:04:11">2023-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/vue/vueLeakFilling/" title="vue知识点查漏补缺"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://edge-labo.com/wp-content/uploads/2021/09/image1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue知识点查漏补缺"/></a><div class="content"><a class="title" href="/vue/vueLeakFilling/" title="vue知识点查漏补缺">vue知识点查漏补缺</a><time datetime="2023-07-13T02:55:34.308Z" title="更新于 2023-07-13 10:55:34">2023-07-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 郭伟杰</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href='https://cn.keep-silence.com'>国内访问</a>  <a href='https://keep-silence.com'>国外访问</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://fastly.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '7b4f59d781f410b781cd',
      clientSecret: '9ec6c6aaee7eee19fd3a6b3ef0d3d2998a624e00',
      repo: 'ghosie',
      owner: 'guo-weijie',
      admin: ['guo-weijie'],
      id: '6b7c6744b27f5e124419c0c9ae6dd70f',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://fastly.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>